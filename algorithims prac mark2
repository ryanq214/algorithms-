
//this is similar to another street fighter selection challenge that i have done but this one is harder.  the fighter selection grid will be different each time and there will be less fighters in some of the rows(arrays)
//here is an example:The first character of the first row (Ryu) is not aligned with the first of the second row (Balrog) but with the second (Ken) and the same goes with the other side; therefore we need to introduce something new, like an offset: the Empty Space.
//The empty space, represented as empty string "", will allow us to keep the grid aligned and rectangular, with spaces that won't be selectable. In this case we need 2 empty spaces (3 rows x 6 columns = 18 slots, 18 slots - 16 characters = 2 empty spaces). Like this:
// |        | Ryu    | E.Honda  | Blanka  | Guile   |         |
// | Balrog | Ken    | Chun Li  | Zangief | Dhalsim | Sagat   |
// | Vega   | T.Hawk | Fei Long | Deejay  | Cammy   | M.Bison |
//The moves of the selection cursor are the same as before: rotate horizontally but stop vertically. When you find empty spaces (1 or more) you need to skip them if you approach them horizontally and get to the next selectable slot with the next fighter on the left or right; and if you approach them vertically you need to just stop and stay where you are.
//Example: if you are on Ryu and move left, you must get to Guile; if you are on Balrog and move up, you must stay on Balrog.
//Notice: I might put empty spaces right in the middle and the rectangular grids can be any size, not only 3x6, deal with this too.
//WHAT'S NEW
//So, let's resume what are the new issues in this harder version of the Kata:
//    The initial position might be any non-empty slot in the grid (given as input).
//    The characters grid (also given as input) might have any rectangular layout, not only 3 rows.
//    The grid might contain empty spaces, both on the borders or right in the middle.
function streetFighterSelection(fighters, position, m){
  if (m.length===0){ return [];}
  // first i make these three variables. arr is what i will put in the fighter selected from each m (move).  d is the lenght of the inner arrays in fighters, this is just to make the coding easier so i don't have to type out fighters[x].length-1 each time.
  //x and y will be the position in the fighters array. X will be wich of the two big arrays in fighters (which row of fighters) and Y will be witch fighter in that row ( the element inside that x array)
  var x=position[0],y=position[1],d=fighters[x].length-1, arr=[];
  // i make this for loop to check what move is being made (up, down...) and adjust the x and y variables accordingly
  	for (var i=0; i<m.length; i++){
      // if the move is up or down then i change the x var which will change which of the two arrays is being selected in the fighters array.
      // but as the selecter can't go up past the top row or down past the bottom row if this happense then i leave the x value as it is.  i also make sure that the next fighter choosen isn't a blank space ("").
      //with this harder street fighter challenge i also have to check for white spaces. so moving up or down i treat these white spaces like i can't go any farther in that direct so i leave the x variable as it is.
      if (m[i]==="up" && (x!=0) && (fighters[x-1][y] != "")){ x--};
      if (m[i]=== "down" && (x!=fighters.length-1) && (fighters[x+1][y] != "")) { x++ };
      // if the move is right or left i change the y variable which will change what fighter in that row is being selected.
      // but just like the x variable there is a twist. if the y value is all the way to the right and moves right it goes back to the begining of that row, same with the left it will go to the end of the row.
      //the white spaces make the left and right movemenents much harder than up or down.  if the white space is in the middle of the array then i can just skip two spots in the direction that i am going. but if the white spaces are at the end it is harder.
      //whichever way i am going i have to check for the white spaces, if that space happens to be the end of that row in whichever way then i have to check if the spot i am going to switch to is also a white space.
      //for example if i am going left and the row has 4 spots and i start of in the second (index 1) and there are white spaces at both ends then i have to skip three times to end on index 2.
      if (m[i]=== "right"){
        if (y===d){
            if (fighters[x][0] != ""){ y=0 }
        	else { y=1;}
        }
        //here is where i have to check two spaces in advance for the white spaces and check if i am at the end of the row if i skip that space or if the left most space is a white space.
        else if (fighters[x][y+1] === ""){
          	if (y+1===d){
              if (fighters[x][0] != ""){ y=0 }
              else {y=1}	}
          	else {y+=2}
        }
        else { y++ }; 	}
      if (m[i]==="left"){
        if (y===0){
            if (fighters[x][d] != "" ){ y=d}
          	else { y=d-1}
        }
        //here i am checking two spots to the left like i did with the right movement
        else if (fighters[x][y-1]=== ""){
          if (y-1===0){
            if (fighters[x][d] != "" ){ y=d}
            else { y=d-1;}
          }
          else {y-=2}
        }
        else { y--};	}
      // at the end of each iteration of the loop i push the result of the new position in fighters into the arr array.
      arr.push (fighters[x][y]);
    }
  return arr;
}
var f =[
	[       "",    "Ryu",  "E.Honda",  "Blanka",   "Guile", ""       ],
	[ "Balrog",    "Ken",  "Chun Li", "Zangief", "Dhalsim", "Sagat"  ],
	[   "Vega", "T.Hawk", "Fei Long",  "Deejay",   "Cammy", "M.Bison"]
];
console.log(streetFighterSelection(f, [1,5],["up","up","up","up"]));
//-->['Sagat','Sagat','Sagat','Sagat'];

//You will be given an array of objects representing data about developers who have signed up to attend the next web development meetup that you are organising. Three programming languages will be represented: Python, Ruby and JavaScript.
//return true if the number of meetup participants representing any of the three programming languages is at MOST 2 times higher than the number of developers representing any of the remaining programming languages; or
//return false otherwise.

function isLanguageDiverse(list) {
  // first i make an obj with the three languages with all of their values at 0.
  var obj= { "JavaScript":0, "Ruby":0, "Python":0 };
  // i use the map() method to run throught he list and every time it goes through someone's dat it increase that lanugaes value in the obj object.
  list.map( function (c,i,a) { return obj[c.language] ++});
  // now i make two for loops to run through obj.
  for (var i in obj){
    // this inner loop allows the outer loop to check all of the other values in obj making sure that the outer loops value isn't more than two times bigger an any other lanugae.  if it is it returns false.
    // i used a second inside for loop so i could check every value agains all other values not just the ones after it which is what i thought would happen if used just one loop.
    for (var d in obj){
    	if (obj[i]> (obj[d]*2) ) { return false;}
    }
  }
  // now i return true, which the function should only get this far if it meets the challenges requirements
  return true;
}
var l1 = [
  { firstName: 'Daniel', lastName: 'J.', country: 'Aruba', continent: 'Americas', age: 42, language: 'Python' },
  { firstName: 'Kseniya', lastName: 'T.', country: 'Belarus', continent: 'Europe', age: 22, language: 'Ruby' },
  { firstName: 'Sou', lastName: 'B.', country: 'Japan', continent: 'Asia', age: 43, language: 'Ruby' },
  { firstName: 'Hanna', lastName: 'L.', country: 'Hungary', continent: 'Europe', age: 95, language: 'JavaScript' },
  { firstName: 'Jayden', lastName: 'P.', country: 'Jamaica', continent: 'Americas', age: 18, language: 'JavaScript' },
  { firstName: 'Joao', lastName: 'D.', country: 'Portugal', continent: 'Europe', age: 25, language: 'JavaScript' }
];
console.log( isLanguageDiverse(l1));
//-->false  as the number of JavaScript developers (3) is 3 times higher than the number of Python developers (1). It can't be more than 2 times higher to be regarded as language-diverse.

//In this kata, your goal is to write a function which will reverse the vowels in a string. Any characters which are not vowels should remain in their original position. Here are some examples:
function reverseVowels(str) {
  //I make several variables for this challenge. vow is an array of all the vowels both upper and lower case, this is to compare the letter in the given string.  count will be used to find the vowel indexes in srting.
  //arr is a copy of str.split that will be left along and used for switching vowels in str.  str i change into an array with all of the letters and elements split apart.
  var vow=["a","e","i","o","u","A","E","I","O","U"], count= new Object(), arr=str.split(""),str=str.split("");
  // here i use the map method to run through the str array and every time i find a vowel(using the vow array to check) i put that index number into the count object.
  str.map( function (c,i,a) { if (vow.indexOf(c)!=-1){return count[i]=i;} });
  // now i make two more variables.  x which is the count obj in array form, and y which is the same thing but reversed.  i will use these in the loop below
  var x=Object.keys(count), y=Object.keys(count).reverse();
  //here i make a for loop to switch the vowels.  i made the loop go half the length of x which is how many vowels there are in str. i  did this because i will be using y (wich is x reversed) and x together to switch the vowels so i only need to go half the lenght of each
  for (var i=0; i<x.length/2; i++){
    // each iteration of the loop i make use x and y as index's in the str array
    // in the first iteratoin i make the first vowel in str (which would be the first number in x) equal the last vowel (which is the last number in y as it is the revers of x). And vice versa using the arr array which is not changed at all so it equals the original str array.
    str[x[i]]=str[y[i]];
    str[y[i]]=arr[x[i]];
  }
  return	str.join("");
}
console.log(reverseVowels("Hello!")); // "Holle!"
console.log(reverseVowels("Tomatoes")); // "Temotaos"
console.log(reverseVowels("Reverse Vowels In A String")); // "RivArsI Vewols en e Streng"

//The DNA is a long sequence of either cytosine (C), guanine (G), adenine (A), or thymine (T) and their order is crucial for the transmission of genetic information. The reading of this sequence doesn't always happen from the start to the end, but there are some regions that need to be repeated. To do so, the organisms developed a system composed by “transcription factors”. A transcription factor is a molecule that binds to specific DNA sequence (binding sites), thereby controlling the number of repetitions of that sequence.
//Given these group of transcription factors and relative binding sites:
/*
ATF6: "TGACGT"
CREB: "TGACGCA"
cMyc: "CACGTG"
Gata1: "GATT"
AhR: "TGCGTG"		*/
//Write a function transFactors that takes the argument seq and returns the transcription factor(s) that bind and the binding position(s) in the sequence (starting from 1). The output should be an object containing an array of the name(s) of the transcription factor(s) and an array of the binding position(s).
//Please note that some transcription factors could have overlapping binding sites with others (or with themselves).
function transFactors(seq) {
  var x,y,z,outp={},ind={"ATF6":[],"CREB":[], "cMyc":[], "Gata1":[], "AhR":[]}, tf={"ATF6":"TGACGT","CREB":"TGACGCA", "cMyc": "CACGTG", "Gata1": "GATT", "AhR": "TGCGTG"};
  // i made several variables for this challenge.  x,y,z will be explained in the for loop.  outp means output and is what i will return.  ind is what i will put the index values in if any of the sequences match seq. and tf is what i will use to compare seq to.

  for (var i=0; i<seq.length; i++){	// this is a for loop running through the seq given.  i made the x,y,and z variables to make writting code easier incase i had to use them more than once, and to make it more readable.

    //these three variables are the length of characters in the tf object (the specific character sets were looking for) the start of each one is the character at i in this iteration of the loop and the next 5 character for x, next 3 characters for y, and next 6 for z.
    x=seq[i]+seq[i+1]+seq[i+2]+seq[i+3]+ seq[i+4]+seq[i+5];
    y=seq[i]+seq[i+1]+seq[i+2]+seq[i+3];
    z=seq[i]+seq[i+1]+seq[i+2]+seq[i+3]+ seq[i+4]+seq[i+5]+seq[i+6];

    for (var d in tf){//this is an inner for loop running through the tf object comparing x,y, and z to all of the sequences in tf.  if it finds a match it pushes that starting index into the match's array in the ind object.

      	if (x===tf[d]){ ind[d].push(i+1)};
      	if(y===tf[d]){ind[d].push(i+1)};
      	if(z===tf[d]){ind[d].push(i+1)};
    }// end of inner loop
  }//end of outer loop

  for (var x in ind){// this for loop goes through the ind object and checks the values(arrays) of each property, if their array length is at least one it pushes the property and value into the outp obj..  any factors that had a match will have at least one value in their array's.

    if (ind[x].length>=1){
    	outp[x]=ind[x]; }
  }//end of loop
  return outp;
}
seq = "ATGGCTGACGTCGTCATGGCGCCCCGATTGAACGATTCCTCCTCCT"
console.log (transFactors(seq));	//-->returns: { ATF6: [ 6 ], Gata1: [ 26, 34 ] }
console.log(transFactors("TGACGTGACGT")); //-->	{ ATF6: [ 1, 6 ] });
console.log(transFactors("TGCGTGCGTG"));//-->{ AhR: [ 1, 5 ] });

//A traveling salesman has to visit clients. He got each client's address e.g. "432 Main Long Road St. Louisville OH 43071" as a list.
//The basic zipcode format usually consists of two capital letters followed by a white space and five digits (OH 43071). The list of clients to visit was given as a string of all addresses, each separated from the others by a comma, e.g. :
//To ease his travel he wants to group the list by zipcode.
//write a function travel that will take two parameters r (list of all clients' addresses) and zipcode and returns a string in the following format:
//zipcode:street and town,street and town,.../house number,house number,...
//The street numbers must be in the same order as the streets where they belong.
//If a given zipcode doesn't exist in the list of clients' addresses return "zipcode:/"
function travel(r, zipcode) {
  r=r.split(","); // first i split the r string by the comma so i can work with each adress seperatly.

  var zi, arr=[],sn=[],x; // i made four variables for this challenge. zi would be the starting index of the zip code in each adress.  arr is where i put the addresses with the right zipcode to work on. sn is where i will put the home number of each address in arr.  x is what i will use to put the home numbers in sn.

  for (var i=0; i<r.length; i++){// in this loop I will compare each adresses zip code to find the right ones.  for this i use the zi to find the starting index of the zip code in each address. i put the riht ones into the arr array.

    zi=r[i].length-8;
    if (zipcode===r[i][zi]+r[i][zi+1]+r[i][zi+2]+r[i][zi+3]+r[i][zi+4]+r[i][zi+5]+r[i][zi+6]+r[i][zi+7]){
        arr.push(r[i]);}
  }// end of loop

  for (var i=0; i<arr.length; i++){// in this loop i mess with the arr array going through each address to return in the right way for the challenge.

    zi=arr[i].length-8;// i use zi again to help find the zip code in the address

  	arr[i]=arr[i].split(""); arr[i].splice(zi-1);arr[i]=arr[i].join("");
    //with the code above i split each address into the individual character.  then i get rid of the zip code at the end of each address and pop the white space at the end. Finally i put the address back together.

    arr[i]=arr[i].split(" "); x=arr[i].shift(); arr[i]=arr[i].join(" ");
    //in this line i once again split each address but this time i split it by white spaces keeping the words together. And as the firs index in this equals the house number i get rid of it in each element and put that into the x variable.  And then i join the address back together.

    sn.push(x);// here i push the house number that currently equals x into the sn array.
  }// end of loop

  if (arr.length===0){ return `${zipcode}:/`};	// here i check if any address had a zip code that matched, if none did then i returned the default answer

  return zipcode + ":" +(arr.join(",")) + "/" + sn.join(",");// here i join the zipcode, arr , and sn together to form my answer in the way required.
}
var r = "123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,786 High Street Pollocksville NY 56432"
console.log(travel(r, "OH 43071"))// --> "OH 43071:Main Street St. Louisville,Main Long Road St. Louisville/123,432"
console.log(travel(r, "NY 56432"))// --> "NY 56432:High Street Pollocksville/786"
console.log(travel(r, "NY 5643"))// --> "NY 5643:/"

//in this challenge you have to modify the toString method.  the new method should check if whatever number is given to it is prime.
//if the number is prime you should return the ads var below plus the number.  if it is not prime then return the number as a string.
var ads="\nNow is the time for advertisements:\n"+
"My name is myjinxin, 25 years old, Male, \n"+
"unmarried, handsome, rich, looking for\n"+
"a lovely woman as a life partner\n";
Number.prototype.toString=function(){
  var x = this
  for (var i=2; i<x; i++){	// this loop is used to find out if the number is prime

    if (this%i===0){ return x +""}
  }//end of loop

   if (x>1){return ads+x; }// this makes sure that the number (that should be prime at this point) is greater than 1

  else {return x + ""}
}
console.log((7).toString());
/*-->Now is the time for advertisements:
My name is myjinxin, 25 years old, Male,
unmarried, handsome, rich, looking for
a lovely woman as a life partner
7*/
(1).toString();
//-->1
nd

//Check if the elements of an array form an arithmetic progression or if the array contains a sequence of elements that form an arithmetic progression.
//If the entire array forms an arithmetic sequence, the function returns true. If it's not an arithmetic progression itself but it contains at least one, return the index of the element where the first arithmetic sequence starts. If it's not one itself and it doesn't contain any, return false.
//An arithmetic sequence will always consist of at least 3 numbers. If this condition is not satisfied, the function will return undefined.
//The function hasArithmProg takes a single parameter, arr, and can return a boolean, a number(the index) or undefined.
//An arithmetic progression is a sequence of numbers such that the difference between two consecutive terms is a constant quantity.
//e.g. 1, 2, 3, 4,... constant = 1 e.g. 9, 7, 5, 3,... constant = -2

function hasArithmProg(arr) {
  if (arr.length<3){ return undefined};	// here i check if the array has at least three elements in it, if it doesn't i return undefined

  var x=true,temp=arr[0]-arr[1];
  // i made three variables for this challenge.  x is set to true to start with and will be used in the firs loop.  temp is the value of the first index - the second and will also be used in the firs loop.

  for ( var i=0; i<arr.length; i++){// in this loop i check if there is an arithmetic sequence in the entire array. i made the temp variable because it has the value of the difference of the first two indexes.  every iteration of the loop i check to see if the current index minus the next index equals the temp variable (and i made sure that the test won't run on the last element.)
    								//if there is a sequence then every element minus the next should have the same value as temp. if the loop finds a break in the sequence then i make x equal false and break the loop.

   	if ( (i<arr.length-1) && temp != arr[i]-arr[i+1]){
      	x=false; break; }
  }// end of loop

  if (x===true){ return x};// here i check x is still true which it should only be if there is a sequence throught the entire array. if it is I return true.

  for (var i=0; i<arr.length; i++){// in this loop i check if there is a sequence with at least three elements in the array.  if there is i return the index at the starting point of that sequence.

    if (arr[i]-arr[i+1] === arr[i+1]-arr[i+2]){
      return i;}
  }// end of loop

  return x;// here i return x which is false. the function should only get this far if there is no sequence in the array.
}

console.log(hasArithmProg([9,5,1]))//, true);
console.log(hasArithmProg([9,1,2,14,46]))//, false);
console.log(hasArithmProg([90,2,4,6,8,14]))//, 1);
console.log(hasArithmProg([2,10,4,6]))//, false)
console.log(hasArithmProg([9,1]))//, undefined);

//Build a function sumNestedNumbers that finds the sum of all numbers in a series of nested arrays raised to the power of their respective nesting levels. Numbers in the outer most array should be raised to the power of 1.
function sumNestedNumbers(arr,pw) {
  if(pw===undefined) {pw=1};// for this challenge i created another parameter pw.  i set it equal to 1 if it is not alrady set when the function is called.

  var t=0;	//the t variable is the total that i will return
  for (var i=0; i<arr.length; i++){// i made a loop to go through and check every element of the array.

    if (Array.isArray(arr[i])){		// in this if statement it checks if the element is also an array. if it is an array then i use recursion to call this same function on that element increasing the pw by 1, and then i add that result to t.

      t+=sumNestedNumbers(arr[i], pw+1);
  		}
 	else {t=t+Math.pow(arr[i],pw)};		// if the element is not an array then it adds that element to the power of pw to t.

  };   //end of loop
  return t ;
}

console.log(sumNestedNumbers([1, [2], 3, [4, [5]]  ]))
//-->1 + 2*2 + 3 + 4*4 + 5*5*5 = 149


//"Every even integer greater than 2 can be written as the sum of two primes"---which is known today as the (strong) Goldbach's conjecture.
//Even though it's been thoroughly tested and analyzed and seems to be true, it hasn't been proved yet (thus, remaining a conjecture.)
//Your task is to implement the function in the starter code, taking into account the following:
/*  If the argument isn't even and greater than two, return an empty array.
    For arguments even and greater than two, return a two-element array with two prime numbers whose sum is the given input.
    The two prime numbers must be the farthest ones (the ones with the greatest difference)
    The first prime number must be the smallest one.		*/

function isPrime (num){// 	this function is to check if a number is prime

    for(var i = 2; i < num; i++) {
        if(num % i === 0) {
            return false;
        }
    }
    return num > 1;
}
function checkGoldbach (n) {
  if (n<=2 || n%2!= 0){ return []};	// first i made sure that the number is greater than 2 and not an even number

  if (n===4){ return [2,2]};	// i make this because four was the only number i could think of would return 2 like this.

  var out=[];
  for (var i=3; i<n; i+=2){// this outer loop goes through every odd number between 2 and n

    if (isPrime(i)){	// if the number is prime i use this inner loop

      for (var d=n-1; d>=n/2; d-=2){	//this inner loop looks for a number that is prime going from n to half of n.

        if (isPrime(d) && i+d ===n){	// if it finds a number that adds with i to equal n then it pushes those number into the out array and returns it.

          out.push(i), out.push(d);
          return out;
        }
      }// end of inner loop
  	}// end of if statement
  }// end of outer loop
  return out;	// if no two number were found that match the challenges conditions then the out array is returned empy.

}

console.log(checkGoldbach(2))// -->[]
console.log(checkGoldbach(5))// -->[]
console.log(checkGoldbach(4))// -->[2, 2]
console.log(checkGoldbach(6))// -->[3, 3]
console.log(checkGoldbach(14))// -->[3, 11]
