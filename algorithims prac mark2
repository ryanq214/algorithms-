
//this is similar to another street fighter selection challenge that i have done but this one is harder.  the fighter selection grid will be different each time and there will be less fighters in some of the rows(arrays)
//here is an example:The first character of the first row (Ryu) is not aligned with the first of the second row (Balrog) but with the second (Ken) and the same goes with the other side; therefore we need to introduce something new, like an offset: the Empty Space.
//The empty space, represented as empty string "", will allow us to keep the grid aligned and rectangular, with spaces that won't be selectable. In this case we need 2 empty spaces (3 rows x 6 columns = 18 slots, 18 slots - 16 characters = 2 empty spaces). Like this:
// |        | Ryu    | E.Honda  | Blanka  | Guile   |         |
// | Balrog | Ken    | Chun Li  | Zangief | Dhalsim | Sagat   |
// | Vega   | T.Hawk | Fei Long | Deejay  | Cammy   | M.Bison |
//The moves of the selection cursor are the same as before: rotate horizontally but stop vertically. When you find empty spaces (1 or more) you need to skip them if you approach them horizontally and get to the next selectable slot with the next fighter on the left or right; and if you approach them vertically you need to just stop and stay where you are.
//Example: if you are on Ryu and move left, you must get to Guile; if you are on Balrog and move up, you must stay on Balrog.
//Notice: I might put empty spaces right in the middle and the rectangular grids can be any size, not only 3x6, deal with this too.
//WHAT'S NEW
//So, let's resume what are the new issues in this harder version of the Kata:
//    The initial position might be any non-empty slot in the grid (given as input).
//    The characters grid (also given as input) might have any rectangular layout, not only 3 rows.
//    The grid might contain empty spaces, both on the borders or right in the middle.
function streetFighterSelection(fighters, position, m){
  if (m.length===0){ return [];}
  // first i make these three variables. arr is what i will put in the fighter selected from each m (move).  d is the lenght of the inner arrays in fighters, this is just to make the coding easier so i don't have to type out fighters[x].length-1 each time.
  //x and y will be the position in the fighters array. X will be wich of the two big arrays in fighters (which row of fighters) and Y will be witch fighter in that row ( the element inside that x array)
  var x=position[0],y=position[1],d=fighters[x].length-1, arr=[];
  // i make this for loop to check what move is being made (up, down...) and adjust the x and y variables accordingly
  	for (var i=0; i<m.length; i++){
      // if the move is up or down then i change the x var which will change which of the two arrays is being selected in the fighters array.
      // but as the selecter can't go up past the top row or down past the bottom row if this happense then i leave the x value as it is.  i also make sure that the next fighter choosen isn't a blank space ("").
      //with this harder street fighter challenge i also have to check for white spaces. so moving up or down i treat these white spaces like i can't go any farther in that direct so i leave the x variable as it is.
      if (m[i]==="up" && (x!=0) && (fighters[x-1][y] != "")){ x--};
      if (m[i]=== "down" && (x!=fighters.length-1) && (fighters[x+1][y] != "")) { x++ };
      // if the move is right or left i change the y variable which will change what fighter in that row is being selected.
      // but just like the x variable there is a twist. if the y value is all the way to the right and moves right it goes back to the begining of that row, same with the left it will go to the end of the row.
      //the white spaces make the left and right movemenents much harder than up or down.  if the white space is in the middle of the array then i can just skip two spots in the direction that i am going. but if the white spaces are at the end it is harder.
      //whichever way i am going i have to check for the white spaces, if that space happens to be the end of that row in whichever way then i have to check if the spot i am going to switch to is also a white space.
      //for example if i am going left and the row has 4 spots and i start of in the second (index 1) and there are white spaces at both ends then i have to skip three times to end on index 2.
      if (m[i]=== "right"){
        if (y===d){
            if (fighters[x][0] != ""){ y=0 }
        	else { y=1;}
        }
        //here is where i have to check two spaces in advance for the white spaces and check if i am at the end of the row if i skip that space or if the left most space is a white space.
        else if (fighters[x][y+1] === ""){
          	if (y+1===d){
              if (fighters[x][0] != ""){ y=0 }
              else {y=1}	}
          	else {y+=2}
        }
        else { y++ }; 	}
      if (m[i]==="left"){
        if (y===0){
            if (fighters[x][d] != "" ){ y=d}
          	else { y=d-1}
        }
        //here i am checking two spots to the left like i did with the right movement
        else if (fighters[x][y-1]=== ""){
          if (y-1===0){
            if (fighters[x][d] != "" ){ y=d}
            else { y=d-1;}
          }
          else {y-=2}
        }
        else { y--};	}
      // at the end of each iteration of the loop i push the result of the new position in fighters into the arr array.
      arr.push (fighters[x][y]);
    }
  return arr;
}
var f =[
	[       "",    "Ryu",  "E.Honda",  "Blanka",   "Guile", ""       ],
	[ "Balrog",    "Ken",  "Chun Li", "Zangief", "Dhalsim", "Sagat"  ],
	[   "Vega", "T.Hawk", "Fei Long",  "Deejay",   "Cammy", "M.Bison"]
];
console.log(streetFighterSelection(f, [1,5],["up","up","up","up"]));
//-->['Sagat','Sagat','Sagat','Sagat'];

//You will be given an array of objects representing data about developers who have signed up to attend the next web development meetup that you are organising. Three programming languages will be represented: Python, Ruby and JavaScript.
//return true if the number of meetup participants representing any of the three programming languages is at MOST 2 times higher than the number of developers representing any of the remaining programming languages; or
//return false otherwise.

function isLanguageDiverse(list) {
  // first i make an obj with the three languages with all of their values at 0.
  var obj= { "JavaScript":0, "Ruby":0, "Python":0 };
  // i use the map() method to run throught he list and every time it goes through someone's dat it increase that lanugaes value in the obj object.
  list.map( function (c,i,a) { return obj[c.language] ++});
  // now i make two for loops to run through obj.
  for (var i in obj){
    // this inner loop allows the outer loop to check all of the other values in obj making sure that the outer loops value isn't more than two times bigger an any other lanugae.  if it is it returns false.
    // i used a second inside for loop so i could check every value agains all other values not just the ones after it which is what i thought would happen if used just one loop.
    for (var d in obj){
    	if (obj[i]> (obj[d]*2) ) { return false;}
    }
  }
  // now i return true, which the function should only get this far if it meets the challenges requirements
  return true;
}
var l1 = [
  { firstName: 'Daniel', lastName: 'J.', country: 'Aruba', continent: 'Americas', age: 42, language: 'Python' },
  { firstName: 'Kseniya', lastName: 'T.', country: 'Belarus', continent: 'Europe', age: 22, language: 'Ruby' },
  { firstName: 'Sou', lastName: 'B.', country: 'Japan', continent: 'Asia', age: 43, language: 'Ruby' },
  { firstName: 'Hanna', lastName: 'L.', country: 'Hungary', continent: 'Europe', age: 95, language: 'JavaScript' },
  { firstName: 'Jayden', lastName: 'P.', country: 'Jamaica', continent: 'Americas', age: 18, language: 'JavaScript' },
  { firstName: 'Joao', lastName: 'D.', country: 'Portugal', continent: 'Europe', age: 25, language: 'JavaScript' }
];
console.log( isLanguageDiverse(l1));
//-->false  as the number of JavaScript developers (3) is 3 times higher than the number of Python developers (1). It can't be more than 2 times higher to be regarded as language-diverse.

//In this kata, your goal is to write a function which will reverse the vowels in a string. Any characters which are not vowels should remain in their original position. Here are some examples:
function reverseVowels(str) {
  //I make several variables for this challenge. vow is an array of all the vowels both upper and lower case, this is to compare the letter in the given string.  count will be used to find the vowel indexes in srting.
  //arr is a copy of str.split that will be left along and used for switching vowels in str.  str i change into an array with all of the letters and elements split apart.
  var vow=["a","e","i","o","u","A","E","I","O","U"], count= new Object(), arr=str.split(""),str=str.split("");
  // here i use the map method to run through the str array and every time i find a vowel(using the vow array to check) i put that index number into the count object.
  str.map( function (c,i,a) { if (vow.indexOf(c)!=-1){return count[i]=i;} });
  // now i make two more variables.  x which is the count obj in array form, and y which is the same thing but reversed.  i will use these in the loop below
  var x=Object.keys(count), y=Object.keys(count).reverse();
  //here i make a for loop to switch the vowels.  i made the loop go half the length of x which is how many vowels there are in str. i  did this because i will be using y (wich is x reversed) and x together to switch the vowels so i only need to go half the lenght of each
  for (var i=0; i<x.length/2; i++){
    // each iteration of the loop i make use x and y as index's in the str array
    // in the first iteratoin i make the first vowel in str (which would be the first number in x) equal the last vowel (which is the last number in y as it is the revers of x). And vice versa using the arr array which is not changed at all so it equals the original str array.
    str[x[i]]=str[y[i]];
    str[y[i]]=arr[x[i]];
  }
  return	str.join("");
}
console.log(reverseVowels("Hello!")); // "Holle!"
console.log(reverseVowels("Tomatoes")); // "Temotaos"
console.log(reverseVowels("Reverse Vowels In A String")); // "RivArsI Vewols en e Streng"

//The DNA is a long sequence of either cytosine (C), guanine (G), adenine (A), or thymine (T) and their order is crucial for the transmission of genetic information. The reading of this sequence doesn't always happen from the start to the end, but there are some regions that need to be repeated. To do so, the organisms developed a system composed by “transcription factors”. A transcription factor is a molecule that binds to specific DNA sequence (binding sites), thereby controlling the number of repetitions of that sequence.
//Given these group of transcription factors and relative binding sites:
/*
ATF6: "TGACGT"
CREB: "TGACGCA"
cMyc: "CACGTG"
Gata1: "GATT"
AhR: "TGCGTG"		*/
//Write a function transFactors that takes the argument seq and returns the transcription factor(s) that bind and the binding position(s) in the sequence (starting from 1). The output should be an object containing an array of the name(s) of the transcription factor(s) and an array of the binding position(s).
//Please note that some transcription factors could have overlapping binding sites with others (or with themselves).
function transFactors(seq) {
  var x,y,z,outp={},ind={"ATF6":[],"CREB":[], "cMyc":[], "Gata1":[], "AhR":[]}, tf={"ATF6":"TGACGT","CREB":"TGACGCA", "cMyc": "CACGTG", "Gata1": "GATT", "AhR": "TGCGTG"};
  // i made several variables for this challenge.  x,y,z will be explained in the for loop.  outp means output and is what i will return.  ind is what i will put the index values in if any of the sequences match seq. and tf is what i will use to compare seq to.

  for (var i=0; i<seq.length; i++){	// this is a for loop running through the seq given.  i made the x,y,and z variables to make writting code easier incase i had to use them more than once, and to make it more readable.

    //these three variables are the length of characters in the tf object (the specific character sets were looking for) the start of each one is the character at i in this iteration of the loop and the next 5 character for x, next 3 characters for y, and next 6 for z.
    x=seq[i]+seq[i+1]+seq[i+2]+seq[i+3]+ seq[i+4]+seq[i+5];
    y=seq[i]+seq[i+1]+seq[i+2]+seq[i+3];
    z=seq[i]+seq[i+1]+seq[i+2]+seq[i+3]+ seq[i+4]+seq[i+5]+seq[i+6];

    for (var d in tf){//this is an inner for loop running through the tf object comparing x,y, and z to all of the sequences in tf.  if it finds a match it pushes that starting index into the match's array in the ind object.

      	if (x===tf[d]){ ind[d].push(i+1)};
      	if(y===tf[d]){ind[d].push(i+1)};
      	if(z===tf[d]){ind[d].push(i+1)};
    }// end of inner loop
  }//end of outer loop

  for (var x in ind){// this for loop goes through the ind object and checks the values(arrays) of each property, if their array length is at least one it pushes the property and value into the outp obj..  any factors that had a match will have at least one value in their array's.

    if (ind[x].length>=1){
    	outp[x]=ind[x]; }
  }//end of loop
  return outp;
}
seq = "ATGGCTGACGTCGTCATGGCGCCCCGATTGAACGATTCCTCCTCCT"
console.log (transFactors(seq));	//-->returns: { ATF6: [ 6 ], Gata1: [ 26, 34 ] }
console.log(transFactors("TGACGTGACGT")); //-->	{ ATF6: [ 1, 6 ] });
console.log(transFactors("TGCGTGCGTG"));//-->{ AhR: [ 1, 5 ] });

//A traveling salesman has to visit clients. He got each client's address e.g. "432 Main Long Road St. Louisville OH 43071" as a list.
//The basic zipcode format usually consists of two capital letters followed by a white space and five digits (OH 43071). The list of clients to visit was given as a string of all addresses, each separated from the others by a comma, e.g. :
//To ease his travel he wants to group the list by zipcode.
//write a function travel that will take two parameters r (list of all clients' addresses) and zipcode and returns a string in the following format:
//zipcode:street and town,street and town,.../house number,house number,...
//The street numbers must be in the same order as the streets where they belong.
//If a given zipcode doesn't exist in the list of clients' addresses return "zipcode:/"
function travel(r, zipcode) {
  r=r.split(","); // first i split the r string by the comma so i can work with each adress seperatly.

  var zi, arr=[],sn=[],x; // i made four variables for this challenge. zi would be the starting index of the zip code in each adress.  arr is where i put the addresses with the right zipcode to work on. sn is where i will put the home number of each address in arr.  x is what i will use to put the home numbers in sn.

  for (var i=0; i<r.length; i++){// in this loop I will compare each adresses zip code to find the right ones.  for this i use the zi to find the starting index of the zip code in each address. i put the riht ones into the arr array.

    zi=r[i].length-8;
    if (zipcode===r[i][zi]+r[i][zi+1]+r[i][zi+2]+r[i][zi+3]+r[i][zi+4]+r[i][zi+5]+r[i][zi+6]+r[i][zi+7]){
        arr.push(r[i]);}
  }// end of loop

  for (var i=0; i<arr.length; i++){// in this loop i mess with the arr array going through each address to return in the right way for the challenge.

    zi=arr[i].length-8;// i use zi again to help find the zip code in the address

  	arr[i]=arr[i].split(""); arr[i].splice(zi-1);arr[i]=arr[i].join("");
    //with the code above i split each address into the individual character.  then i get rid of the zip code at the end of each address and pop the white space at the end. Finally i put the address back together.

    arr[i]=arr[i].split(" "); x=arr[i].shift(); arr[i]=arr[i].join(" ");
    //in this line i once again split each address but this time i split it by white spaces keeping the words together. And as the firs index in this equals the house number i get rid of it in each element and put that into the x variable.  And then i join the address back together.

    sn.push(x);// here i push the house number that currently equals x into the sn array.
  }// end of loop

  if (arr.length===0){ return `${zipcode}:/`};	// here i check if any address had a zip code that matched, if none did then i returned the default answer

  return zipcode + ":" +(arr.join(",")) + "/" + sn.join(",");// here i join the zipcode, arr , and sn together to form my answer in the way required.
}
var r = "123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,786 High Street Pollocksville NY 56432"
console.log(travel(r, "OH 43071"))// --> "OH 43071:Main Street St. Louisville,Main Long Road St. Louisville/123,432"
console.log(travel(r, "NY 56432"))// --> "NY 56432:High Street Pollocksville/786"
console.log(travel(r, "NY 5643"))// --> "NY 5643:/"

//in this challenge you have to modify the toString method.  the new method should check if whatever number is given to it is prime.
//if the number is prime you should return the ads var below plus the number.  if it is not prime then return the number as a string.
var ads="\nNow is the time for advertisements:\n"+
"My name is myjinxin, 25 years old, Male, \n"+
"unmarried, handsome, rich, looking for\n"+
"a lovely woman as a life partner\n";
Number.prototype.toString=function(){
  var x = this
  for (var i=2; i<x; i++){	// this loop is used to find out if the number is prime

    if (this%i===0){ return x +""}
  }//end of loop

   if (x>1){return ads+x; }// this makes sure that the number (that should be prime at this point) is greater than 1

  else {return x + ""}
}
console.log((7).toString());
/*-->Now is the time for advertisements:
My name is myjinxin, 25 years old, Male,
unmarried, handsome, rich, looking for
a lovely woman as a life partner
7*/
(1).toString();
//-->1
nd

//Check if the elements of an array form an arithmetic progression or if the array contains a sequence of elements that form an arithmetic progression.
//If the entire array forms an arithmetic sequence, the function returns true. If it's not an arithmetic progression itself but it contains at least one, return the index of the element where the first arithmetic sequence starts. If it's not one itself and it doesn't contain any, return false.
//An arithmetic sequence will always consist of at least 3 numbers. If this condition is not satisfied, the function will return undefined.
//The function hasArithmProg takes a single parameter, arr, and can return a boolean, a number(the index) or undefined.
//An arithmetic progression is a sequence of numbers such that the difference between two consecutive terms is a constant quantity.
//e.g. 1, 2, 3, 4,... constant = 1 e.g. 9, 7, 5, 3,... constant = -2

function hasArithmProg(arr) {
  if (arr.length<3){ return undefined};	// here i check if the array has at least three elements in it, if it doesn't i return undefined

  var x=true,temp=arr[0]-arr[1];
  // i made three variables for this challenge.  x is set to true to start with and will be used in the firs loop.  temp is the value of the first index - the second and will also be used in the firs loop.

  for ( var i=0; i<arr.length; i++){// in this loop i check if there is an arithmetic sequence in the entire array. i made the temp variable because it has the value of the difference of the first two indexes.  every iteration of the loop i check to see if the current index minus the next index equals the temp variable (and i made sure that the test won't run on the last element.)
    								//if there is a sequence then every element minus the next should have the same value as temp. if the loop finds a break in the sequence then i make x equal false and break the loop.

   	if ( (i<arr.length-1) && temp != arr[i]-arr[i+1]){
      	x=false; break; }
  }// end of loop

  if (x===true){ return x};// here i check x is still true which it should only be if there is a sequence throught the entire array. if it is I return true.

  for (var i=0; i<arr.length; i++){// in this loop i check if there is a sequence with at least three elements in the array.  if there is i return the index at the starting point of that sequence.

    if (arr[i]-arr[i+1] === arr[i+1]-arr[i+2]){
      return i;}
  }// end of loop

  return x;// here i return x which is false. the function should only get this far if there is no sequence in the array.
}

console.log(hasArithmProg([9,5,1]))//, true);
console.log(hasArithmProg([9,1,2,14,46]))//, false);
console.log(hasArithmProg([90,2,4,6,8,14]))//, 1);
console.log(hasArithmProg([2,10,4,6]))//, false)
console.log(hasArithmProg([9,1]))//, undefined);

//Build a function sumNestedNumbers that finds the sum of all numbers in a series of nested arrays raised to the power of their respective nesting levels. Numbers in the outer most array should be raised to the power of 1.
function sumNestedNumbers(arr,pw) {
  if(pw===undefined) {pw=1};// for this challenge i created another parameter pw.  i set it equal to 1 if it is not alrady set when the function is called.

  var t=0;	//the t variable is the total that i will return
  for (var i=0; i<arr.length; i++){// i made a loop to go through and check every element of the array.

    if (Array.isArray(arr[i])){		// in this if statement it checks if the element is also an array. if it is an array then i use recursion to call this same function on that element increasing the pw by 1, and then i add that result to t.

      t+=sumNestedNumbers(arr[i], pw+1);
  		}
 	else {t=t+Math.pow(arr[i],pw)};		// if the element is not an array then it adds that element to the power of pw to t.

  };   //end of loop
  return t ;
}

console.log(sumNestedNumbers([1, [2], 3, [4, [5]]  ]))
//-->1 + 2*2 + 3 + 4*4 + 5*5*5 = 149


//"Every even integer greater than 2 can be written as the sum of two primes"---which is known today as the (strong) Goldbach's conjecture.
//Even though it's been thoroughly tested and analyzed and seems to be true, it hasn't been proved yet (thus, remaining a conjecture.)
//Your task is to implement the function in the starter code, taking into account the following:
/*  If the argument isn't even and greater than two, return an empty array.
    For arguments even and greater than two, return a two-element array with two prime numbers whose sum is the given input.
    The two prime numbers must be the farthest ones (the ones with the greatest difference)
    The first prime number must be the smallest one.		*/

function isPrime (num){// 	this function is to check if a number is prime

    for(var i = 2; i < num; i++) {
        if(num % i === 0) {
            return false;
        }
    }
    return num > 1;
}
function checkGoldbach (n) {
  if (n<=2 || n%2!= 0){ return []};	// first i made sure that the number is greater than 2 and not an even number

  if (n===4){ return [2,2]};	// i make this because four was the only number i could think of would return 2 like this.

  var out=[];
  for (var i=3; i<n; i+=2){// this outer loop goes through every odd number between 2 and n

    if (isPrime(i)){	// if the number is prime i use this inner loop

      for (var d=n-1; d>=n/2; d-=2){	//this inner loop looks for a number that is prime going from n to half of n.

        if (isPrime(d) && i+d ===n){	// if it finds a number that adds with i to equal n then it pushes those number into the out array and returns it.

          out.push(i), out.push(d);
          return out;
        }
      }// end of inner loop
  	}// end of if statement
  }// end of outer loop
  return out;	// if no two number were found that match the challenges conditions then the out array is returned empy.

}

console.log(checkGoldbach(2))// -->[]
console.log(checkGoldbach(5))// -->[]
console.log(checkGoldbach(4))// -->[2, 2]
console.log(checkGoldbach(6))// -->[3, 3]
console.log(checkGoldbach(14))// -->[3, 11]


//Can you mirror the properties on an object?
//Given an object with properties with no value
/*		abc: -
		arara: -
		xyz: -		*/
//Return a new object that have the properties with its mirrored key!
/*		abc: cba
		arara: arara
		xyz: zyx		*/
//"You cannot change the original object, because if you did that the reflection would change."

function mirror (obj) {
  var nob={};// i created this var nob (new object) to return as the answer

  for (var i in obj){	// in this for loop i go through each property in obj and set that property in nob and make it equal the reverse of that property

    nob[i]=i.split("").reverse().join("");	// to make the value the reverse i split it into individual characters, reverse them, and then join them together again.

  }
  return nob;
};


//Did you ever see the movie called Snakes on a Plane?
//In this Kata there are also snakes on a plane but now YOU can be the hero.
//Count how many snakes are on the plane
//Notes:
//    snakeskins are uniquely patterned with a single character per snake
//    snakes can be any length
// the array that is given to you will have other arrays as the elements (snakes).

function snakesOn(p) {
  var ar=[];	// i made this empy array to push in the letters (snakes) in

  for (var i=0; i<p.length; i++){	// this loop goes through every element in the given p array

    for (var d=0; d<p[i].length; d++){	// this inner loop goes through the array of each i element in the p array.

      if (p[i][d] != "_" && ar.indexOf(p[i][d]) === -1){	// this checks each element (d) firs to make sure that the element isn't "_" and then that the letter isn't already in the ar array.

        ar.push(p[i][d]);	// if the letter isn't in the ar array then i push that letter in ar.
      }	// end of if statement
    }	// end of inner loop
  }		// end of outer loop

  return ar.length;	// finally i check the length of the ar array as the number of snakes.
};

 var aPlane = [
        '_A_AAAAA__'.split(''),
        '_AA____AAA'.split(''),
        'D_AA_____A'.split(''),
        'DD_AAAAA_A'.split(''),
        '_D_____AAA'.split('')
      ]

console.log(snakesOn(aPlane));	//-->2


//all you have to do is determine whether the distances between any visiting cats in the yard are large enough to make for a peaceful afternoon, or whether there is about to be an altercation because they are too close and someone will need to deal with it.
//As input your function will receive a list of strings representing the yard, and an integer representing the minimum distance needed to prevent problems (considering the cats' current states of sleepiness). A point with no cat in it will be represented by a "-" dash. Lou, Mustache Cat, and Raoul will be represented by an upper case L, M, and R respectively. At any particular time all three cats may be in the yard, or maybe two, one, or even none.
//If the number of cats in the yard is one or none, or if the distances between all cats are at least the minimum distance, your function should return True/true/TRUE (depending on what language you're using),
//But if there are two or three cats, and the grid distance between at least two of them is smaller than the minimum distance, your function should return False/false/FALSE.
//the minimum distance is at 6 any less and there will be a cat fight
function peacefulYard(y, min) {
  	var c=[ "M", "L", "R"];	// this var is the cat names as they will appear in the y array.

    for (var i=0; i<y.length; i++){	// outer loop
      for (var d=0; d<y[i].length; d++){	// in this inner loop i check through each element in the y array for the cats (L, M or R).  if I find them then i put that gird spot (i,d) in the c array in place of that cat's name.

        if (c.indexOf(y[i][d]) != -1){
         c[c.indexOf(y[i][d])]= [i,d];}

      }	// end of inner loop
    }	// end of outer loop

  	// in these dis var i find the grid difference between two of the cats in the c array, if there wasn't a particular cat in the y array then the dis var will be a NAN.
  var dis1= Math.sqrt( Math.pow( (c[0][0] -c[1][0]),2) + Math.pow( (c[0][1] -c[1][1]),2) ),
      dis2= Math.sqrt( Math.pow( (c[1][0] -c[2][0]),2) + Math.pow( (c[1][1] -c[2][1]),2) ),
      dis3= Math.sqrt( Math.pow( (c[0][0] -c[2][0]),2) + Math.pow( (c[0][1] -c[2][1]),2) ),
  	  ar=[dis1,dis2,dis3];	// and this var is the dis in an array.

  	for (var i=0; i< ar.length; i++){	// in this loop i check the distances between any cats in the yard is at least the min distance, otherwise i return false.

      if (ar[i] <min){ return false;}
    }
  return true;
}

var one=["------------",
 "------------",
 "-L----------",
 "------------",
 "------------",
 "------------"]; min dis= 10

var two=["------------",
 "---M--------",
 "------------",
 "------------",
 "-------R----",
 "------------"];	// min dis=6

var three=["-----------L",
 			"--R---------",
            "------------",
 			"------------",
 			"------------",
 			"--M---------"];  //min dis= 4
console.log(peacefulYard(one,10));	//--> true
console.log(peacefulYard(two,6));	//--> false
console.log(peacefulYard(three, 4));	//-> true


//In this Kata, you need to simulate an old mobile display, similar to this one:
/*  ***************************
    *                         *
    *                         *
    *        CodeWars         *
    *                         *
    *                         *
    * Menu           Contacts *
    ***************************		*/
//Input Parameters:
//    number of characters for width (n)
//    height-to-width ratio in percentage (p)
//Example: if n=30 and p=40, then display will be 30 characters long and its height will be 40% of n(12 characters in this case).

//Rules and Notes:
/*  the border, as you can see, is filled with *;
    the rounding of divisions and float numbers is always by the integer (1.2, 1.5, 1.9 they are always reduced to 1), keep this in mind when you calculate proportions
    the menus Menu and Contacts are always in the second last line, at 1 character distance respectively from the left and from the right border;
    the CodeWars logo is always in the middle horizontally and in the half-1 line vertically;
    	the width n must be always at least 20 characters and the percentage p must be always at least 30%, take care of this (otherwise menus won't likely fit).
    random tests might get big and percentages might be higher than 100;	*/

function mobileDisplay(n,p){
  p= Math.floor((n*p)/100);	// this sets the p variable to be the p percent of n rounded down to the nearest whole integer.

  var s="", space="*", end="", med="", m="* Menu", c="Contacts *\n", ls=n-16, ms=Math.floor((n-10)/2-1);

  for (var i=0; i<=ms; i++){	// this loop sets the number of spaces required for the medium line with codewars in it.  the spaces are are on both sides of the word codewars, so the med var will be half that number of spaces.

    med+=" ";
  };	// end of loop

 	 // these two if and else statements are to test if the n is odd, because then that would make the necessary spaces on the sides of codewars be uneven.  if it is odd then i add an extra space on the right side.
  if (n%2!=0){ med=( "*" + med + "CodeWars" + med + " *\n") }
  else {med=( "*" + med + "CodeWars" + med + "*\n") }


  for (var i=0; i<n; i++){	// this loop sets the number of * in the s and end var equals to n, and the number of white spaces between the *'s in the middle lines necessary.

    end+="*";
    s+= "*";

    	// this if statement checks for the last iterationof the loop.  if it is then after it changes the end and s var it adds a * at the end of the space var instead of a white space. and then it breaks the loop.
    if (i===n-1){space=space.split(""); space.pop();
                 space=space.join(""); space +="*";
                 s+="\n"; break;}	// end of if statement
    space+= " ";
  }	// end of lop

  for (var i=0; i<p-3; i++){	// this loop to add the lines in the middle of the boxes (ex: *       *\n) with the exception of the middle line that has code wars and the second to last line with Menu and contacs in it and the very last line.

    if (i===Math.floor(p/2-2)){s+=med;continue;}	// this if statement checks if the line about to be made is the middle of the box, if it instead adds the line with the codewars in it.

  	s+=space; s+="\n";
  }	// end of loop

  s+=m;	//this adds the m var ("* Menu") the beginning of the second to last line

  for (var i=0; i<ls; i++){	// this loop adds the number of white spaces necessary between menu and contact

    s+=" ";
  }	// end of loop

  s+=c;	// this adds the end of the second to last line.  the "Contacts *\n"

  s+=end;	//this adds the last line which is the same as the very first.

  return s
}

//Examples:
//    mobileDisplay(30,40):	-->
/*  ******************************
    *                            *
    *                            *
    *                            *
    *                            *
    *    (10)  CodeWars          *
    *                            *
    *                            *
    *                            *
    *                            *
    * Menu(5)  (14)  (9)Contacts *
    ******************************	*/

//		mobileDisplay(25,50):-->
/*    *************************
      *                       *
      *                       *
      *                       *
      *                       *
  (6) *(7) (8)CodeWars    (7) *
      *                       *
      *                       *
      *                       *
      *                       *
      * Menu         Contacts *
      *************************		*/


//You'll have to translate a string to Pilot's alphabet (NATO phonetic alphabet) wiki.
//Ex---Input: If you can read
//Output: Indian Foxtrot Yankee Oscar Uniform Charlie Alfa November Romeo Echo Alfa Delta
//    Keep the punctuation, and remove the spaces.
//    Use Xray without dash or space.
function to_nato(w) {
  		//first i made s as an empy array var, this is what i will put the translations into. And then i made the object alp with has all of the NATO phonetic alphabet with the corresponding Letter in upper case.

  var s=[],alp={ "A":"Alfa","B":"Bravo", "C":"Charlie","D":"Delta","E":"Echo","F":"Foxtrot",
           "G":"Golf","H":"Hotel","I":"India","J":"Juliett","K":"Kilo","L":"Lima",
           "M":"Mike","N":"November","O":"Oscar","P":"Papa","Q":"Quebec","R":"Romeo",
           "S":"Sierra","T":"Tango","U":"Uniform","V":"Victor","W":"Whiskey",
           "X":"Xray","Y":"Yankee","Z":"Zulu"  };

  w=w.toUpperCase().split(" ").join("").split("");	// here i made every letter in w uppercase so find them in the alp object.  and then i split the phrase into an array by space, then i joined it all togther to make 1 word which gets rid of all white spaces.  and finally i split it into indiviual letter.

  for (var i=0; i<w.length; i++){	// in this loop i am checking if each character is a letter or not

    		// if the character is a letter then i push that NATO tranlation into the s array.
    if (alp[w[i]]!=undefined){
      s.push(alp[w[i]]);
    }

    		//if the character isn't a letter (which whould only be punctuation of some kind or commas) then i push it straight into the s array.
    else{ s.push(w[i])}

  }	//end of loop
  return s.join(" ");
}
console.log(to_nato(i));


//Given n representing the number of floors build a beautiful multi-million dollar mansions like the ones in the example below:
function myCrib(n) {
  var r="/",roof="",roofwall="",inSpace="", outSpace= (n*2), wall="|", house="|", floor="|";

  for (var i=0; i<outSpace; i++){		//this loop is to maket the necessary spaces between the walls, floor, and bottom of the roof where it touches the house (r).
    r+="_";
    wall+=" ";
    house += " ";
    floor+="_";
  }		// end of loop

  r+="\\";  house += "|"; wall +="|"; floor+="|";		// this line adds the other side to these variables, the other wall

  		//this part is to set up the walls and floor.
  for (var i=0; i<n-2; i++){	// this loop is to expand the walls up and down, to make the full house except the roof and floor;
   wall+= "\n"+ house;
  }		//end of loop

  if (n>1){ wall = wall +"\n" + floor;}	// this is to set the floor and wall together.  if the house is only 1 level i skip this part as just the floor level is enough.
  else { wall=floor;}

  		// this part below is to set up the rest of the roof
  outSpace=n-1;
  for (var i=0; i<n; i++){			// these two loops are to make the majority of the roof with the exception of where it touches the house, which is already made with r .

    for (var d=0; d<=outSpace; d++){	// this inner loop uses the outSpace variable set just before this loop as it's limit.  this is to set the space on the sides of the roof to level it with the rest of the house to make a triagle.
      roofwall+=" ";
    }	// end of inner loop

    outSpace -=1;		// this increments the outSpace var down by 1 to keep the house walls going down proportionalty like the sides of a triagle.

    roof= roof+ roofwall+ "/"+ inSpace+ "\\" + roofwall+ "\n";		//here i add the roofwall with the /, inSpace (which is the space inside the roof between the / and \), \, and \n to make a full level of the roof.

    roofwall=""; inSpace+="  ";		// here i set the roofwall back to blank to start the next level to add onto the roof var, and i also add two spaces to the inSpace var to make the next level proportionate.
  }

  return roof+ r+"\n"+ wall;
}

/*   /\		(8 splaces of line across this house (n *2)+2
    /  \	8 lines up and down
   /    \
  /______\  // number of floors 3		(bottom of roof has 6 spaces(_) between the /\
  |      |
  |      |
  |______|
     /\			6 spaces across (n*2)+2
    /  \
   /____\
   |    |   // 2 floors
   |____|
     /\
    /__\    // 1 floor
    |__|						*/
console.log(myCrib(3));
console.log(myCrib(2));
console.log(myCrib(1));


//Given an array as an argument complete the function countSmileys that should return the total number of smiling faces.
//Rules for a smiling face:
/*-Each smiley face must contain a valid pair of eyes. Eyes can be marked as : or ;
  -A smiley face can have a nose but it does not have to. Valid characters for a nose are - or ~
  -Every smiling face must have a smiling mouth that should be marked with either ) or D.	*/
//Valid smiley face examples:
//	:)  :D  ;-D  :~)
//Invalid smiley faces:
//	;(  :>   :}   :]

function countSmileys(arr) {
	var t=0, smiles=[":)",";)",":D",";-D",":~)",":-D",";D",":-)",";~)",";~D"];
  arr.filter(function (c,i,a){ c=c.replace(/\s+/g,"");if (smiles.indexOf(c) != -1){return t+=1;} } )
  return t;
}
console.log(countSmileys([':)', ';(', ';}', ':-D']));       // should return 2;
console.log(countSmileys([';D', ':-(', ':-)', ';~)']));     // should return 3;
console.log(countSmileys([" ;~( "," ;D "," :> "," ;-D "," :o) "," :~) "," :)"])); // should return 4

//this is another version
/*function countSmileys(arr) {
	var t=0;
  arr.filter(function (c,i,a){ c=c.replace(/\s+/g,"");c=c.split("");
                              if ( (c[c.length-1] === ")" || c[c.length-1]==="D")
                              && c[c.length-2]!= "o")   { return t+=1;} } )
  return t;
}	*/


this is another version of the code
function countDays(d){
  var today = new Date(), tdarr=[], d8arr=[], daysLeft, currentMonthDays, dMonth, tot_days=0, leapYearDay=0, difvar=2020,
      daysLeft=[[1,31],[2,28],[3,31],[4,30],[5,31],[6,30],[7,31],[8,31],[9,30],[10,31],[11,30],[12,31]	];

  tdarr[0]= today.getMonth(); d8arr[0]=d.getMonth();		//these three lines are to set up the tdarr(today) and d8arr (date given-d) arrays so it's Month, day, year.
  tdarr[1]= today.getDate();	d8arr[1]= d.getDate();
  tdarr[2]= today.getFullYear();	d8arr[2]= d.getFullYear();

  if (tdarr.join(" ")=== d8arr.join(" ")){ return "Today is the day!"}	//this line checks if the dates are the same

  		//these three lines are to check if d is in the past by checking it against today's date by checking the year, then month, and then day
  if (tdarr[2]>d8arr[2]){ return "The day is in the past!"}		//this checks year
  else if (tdarr[2]===d8arr[2] && tdarr[0]>d8arr[0]){ return "The day is in the past!"}		// checks month
  else if (tdarr[2]===d8arr[2] && tdarr[0]===d8arr[0] && tdarr[1] >d8arr[1]){ return "The day is in the past!"}		//checks day

  dMonth=d8arr[1]		//this var is the days in the month of d that have passed.
  currentMonthDays= daysLeft[tdarr[0]][1]-tdarr[1];	// these two lines are to find how many months are left in the Current month (ex: if taday is jan 29th, then there would be 3 days left in jan.)
    if (currentMonthDays===0){ currentMonthDays= daysLeft[tdarr[0]][1]}; // this line checks if the currentMonth var is equal to zero which should only happen if the curren date given is the last day of that month, in this case i make currentMonthDays equal that months total days.

  if (tdarr[2] ===d8arr[2] && tdarr[0]===d8arr[0]){ return `${d8arr[1] -tdarr[1]} days`}		//this checks if the d given is in the same month as the current month but still in the future, in that case it returns the difference in days.

  for (var i=(tdarr[0]+1); i<(d8arr[0]); i++){	// this loop goes through every month between todays date (td) and the date given (d) (but not those two months) and adds all of the days of those months to the var tot_days
      tot_days +=daysLeft[i][1];
    }	//end of loop

    tot_days += (dMonth+currentMonthDays);	// now i add the differences between how many days are left in the td and d months to the tot_days var.  in this case there are 13 days left in jan and the full 28 days left to get the the d day given.  so 41 days are left between the two dates

  if (tdarr[2]<d8arr[2]){ tot_days +=(365 * (d8arr[2]-tdarr[2])) }		// this line is to add the total number of years (times 365) d is greater than today

  for (var i=2021; i<=d8arr[2]; i+=4){		// this loop is to add a day to the tot_days for each leap year between today and t
    leapYearDay +=1;
    if (difvar + 95.6 < i){ leapYearDay -=1;	difvar=i;}
  }
  tot_days+= leapYearDay;
  //if (d8arr[2] >2019 && d8arr[2]< 2026){ tot_days-=1}

  return `${tot_days} days`;
}
console.log (countDays(new Date("February 28, 2017")))  //-->


//this is another version of the smiles challenge 2 challenges above this.
//apparently there were a few instances of my code not working.

//Given an array as an argument complete the function countSmileys that should return the total number of smiling faces.
//Rules for a smiling face:
/*-Each smiley face must contain a valid pair of eyes. Eyes can be marked as : or ;
  -A smiley face can have a nose but it does not have to. Valid characters for a nose are - or ~
  -Every smiling face must have a smiling mouth that should be marked with either ) or D.	*/
//Valid smiley face examples:
//	:)  :D  ;-D  :~)
//Invalid smiley faces:
//	;(  :>   :}   :]

function countSmileys(arr) {
	var t=0, smiles=[":)",";)",":D",";-D",":~)",":-D",";D",":-)",";~)",";~D",":~D",";-)"];
  					//the smiles array contains every smile that i found in the test cases, i will use this to compare the arr given.
  arr.filter(function (c,i,a){ c=c.replace(/\s+/g,"");if (smiles.indexOf(c) != -1){return t+=1;} } )	//this filters each element of the arr array and checks if that element is in the smiles array, if it it it adds 1 to t.

  return t;
}

console.log(countSmileys([':)', ';(', ';}', ':-D']));       // should return 2;
console.log(countSmileys([';D', ':-(', ':-)', ';~)']));     // should return 3;
console.log(countSmileys([" ;~( "," ;D "," :> "," ;-D "," :o) "," :~) "," :)"])); // should return 4

here is a version of the code above using regular expression
function countSmileys(arr) {
	var t=0;		// this var will be the total number of smiles found
  arr.forEach(function (c,i,a){ if (c.match (/[:;][-~]?[)D]/gi) ){ return t+=1} } )	//this filters each element of the arr array and checks if that element is a smile using regular expression to check, if it is it adds 1 to t.

  return t;
}
