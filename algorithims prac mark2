
//this is similar to another street fighter selection challenge that i have done but this one is harder.  the fighter selection grid will be different each time and there will be less fighters in some of the rows(arrays)
//here is an example:The first character of the first row (Ryu) is not aligned with the first of the second row (Balrog) but with the second (Ken) and the same goes with the other side; therefore we need to introduce something new, like an offset: the Empty Space.
//The empty space, represented as empty string "", will allow us to keep the grid aligned and rectangular, with spaces that won't be selectable. In this case we need 2 empty spaces (3 rows x 6 columns = 18 slots, 18 slots - 16 characters = 2 empty spaces). Like this:
// |        | Ryu    | E.Honda  | Blanka  | Guile   |         |
// | Balrog | Ken    | Chun Li  | Zangief | Dhalsim | Sagat   |
// | Vega   | T.Hawk | Fei Long | Deejay  | Cammy   | M.Bison |
//The moves of the selection cursor are the same as before: rotate horizontally but stop vertically. When you find empty spaces (1 or more) you need to skip them if you approach them horizontally and get to the next selectable slot with the next fighter on the left or right; and if you approach them vertically you need to just stop and stay where you are.
//Example: if you are on Ryu and move left, you must get to Guile; if you are on Balrog and move up, you must stay on Balrog.
//Notice: I might put empty spaces right in the middle and the rectangular grids can be any size, not only 3x6, deal with this too.
//WHAT'S NEW
//So, let's resume what are the new issues in this harder version of the Kata:
//    The initial position might be any non-empty slot in the grid (given as input).
//    The characters grid (also given as input) might have any rectangular layout, not only 3 rows.
//    The grid might contain empty spaces, both on the borders or right in the middle.
function streetFighterSelection(fighters, position, m){
  if (m.length===0){ return [];}
  // first i make these three variables. arr is what i will put in the fighter selected from each m (move).  d is the lenght of the inner arrays in fighters, this is just to make the coding easier so i don't have to type out fighters[x].length-1 each time.
  //x and y will be the position in the fighters array. X will be wich of the two big arrays in fighters (which row of fighters) and Y will be witch fighter in that row ( the element inside that x array)
  var x=position[0],y=position[1],d=fighters[x].length-1, arr=[];
  // i make this for loop to check what move is being made (up, down...) and adjust the x and y variables accordingly
  	for (var i=0; i<m.length; i++){
      // if the move is up or down then i change the x var which will change which of the two arrays is being selected in the fighters array.
      // but as the selecter can't go up past the top row or down past the bottom row if this happense then i leave the x value as it is.  i also make sure that the next fighter choosen isn't a blank space ("").
      //with this harder street fighter challenge i also have to check for white spaces. so moving up or down i treat these white spaces like i can't go any farther in that direct so i leave the x variable as it is.
      if (m[i]==="up" && (x!=0) && (fighters[x-1][y] != "")){ x--};
      if (m[i]=== "down" && (x!=fighters.length-1) && (fighters[x+1][y] != "")) { x++ };
      // if the move is right or left i change the y variable which will change what fighter in that row is being selected.
      // but just like the x variable there is a twist. if the y value is all the way to the right and moves right it goes back to the begining of that row, same with the left it will go to the end of the row.
      //the white spaces make the left and right movemenents much harder than up or down.  if the white space is in the middle of the array then i can just skip two spots in the direction that i am going. but if the white spaces are at the end it is harder.
      //whichever way i am going i have to check for the white spaces, if that space happens to be the end of that row in whichever way then i have to check if the spot i am going to switch to is also a white space.
      //for example if i am going left and the row has 4 spots and i start of in the second (index 1) and there are white spaces at both ends then i have to skip three times to end on index 2.
      if (m[i]=== "right"){
        if (y===d){
            if (fighters[x][0] != ""){ y=0 }
        	else { y=1;}
        }
        //here is where i have to check two spaces in advance for the white spaces and check if i am at the end of the row if i skip that space or if the left most space is a white space.
        else if (fighters[x][y+1] === ""){
          	if (y+1===d){
              if (fighters[x][0] != ""){ y=0 }
              else {y=1}	}
          	else {y+=2}
        }
        else { y++ }; 	}
      if (m[i]==="left"){
        if (y===0){
            if (fighters[x][d] != "" ){ y=d}
          	else { y=d-1}
        }
        //here i am checking two spots to the left like i did with the right movement
        else if (fighters[x][y-1]=== ""){
          if (y-1===0){
            if (fighters[x][d] != "" ){ y=d}
            else { y=d-1;}
          }
          else {y-=2}
        }
        else { y--};	}
      // at the end of each iteration of the loop i push the result of the new position in fighters into the arr array.
      arr.push (fighters[x][y]);
    }
  return arr;
}
var f =[
	[       "",    "Ryu",  "E.Honda",  "Blanka",   "Guile", ""       ],
	[ "Balrog",    "Ken",  "Chun Li", "Zangief", "Dhalsim", "Sagat"  ],
	[   "Vega", "T.Hawk", "Fei Long",  "Deejay",   "Cammy", "M.Bison"]
];
console.log(streetFighterSelection(f, [1,5],["up","up","up","up"]));
//-->['Sagat','Sagat','Sagat','Sagat'];

//You will be given an array of objects representing data about developers who have signed up to attend the next web development meetup that you are organising. Three programming languages will be represented: Python, Ruby and JavaScript.
//return true if the number of meetup participants representing any of the three programming languages is at MOST 2 times higher than the number of developers representing any of the remaining programming languages; or
//return false otherwise.

function isLanguageDiverse(list) {
  // first i make an obj with the three languages with all of their values at 0.
  var obj= { "JavaScript":0, "Ruby":0, "Python":0 };
  // i use the map() method to run throught he list and every time it goes through someone's dat it increase that lanugaes value in the obj object.
  list.map( function (c,i,a) { return obj[c.language] ++});
  // now i make two for loops to run through obj.
  for (var i in obj){
    // this inner loop allows the outer loop to check all of the other values in obj making sure that the outer loops value isn't more than two times bigger an any other lanugae.  if it is it returns false.
    // i used a second inside for loop so i could check every value agains all other values not just the ones after it which is what i thought would happen if used just one loop.
    for (var d in obj){
    	if (obj[i]> (obj[d]*2) ) { return false;}
    }
  }
  // now i return true, which the function should only get this far if it meets the challenges requirements
  return true;
}
var l1 = [
  { firstName: 'Daniel', lastName: 'J.', country: 'Aruba', continent: 'Americas', age: 42, language: 'Python' },
  { firstName: 'Kseniya', lastName: 'T.', country: 'Belarus', continent: 'Europe', age: 22, language: 'Ruby' },
  { firstName: 'Sou', lastName: 'B.', country: 'Japan', continent: 'Asia', age: 43, language: 'Ruby' },
  { firstName: 'Hanna', lastName: 'L.', country: 'Hungary', continent: 'Europe', age: 95, language: 'JavaScript' },
  { firstName: 'Jayden', lastName: 'P.', country: 'Jamaica', continent: 'Americas', age: 18, language: 'JavaScript' },
  { firstName: 'Joao', lastName: 'D.', country: 'Portugal', continent: 'Europe', age: 25, language: 'JavaScript' }
];
console.log( isLanguageDiverse(l1));
//-->false  as the number of JavaScript developers (3) is 3 times higher than the number of Python developers (1). It can't be more than 2 times higher to be regarded as language-diverse.

//In this kata, your goal is to write a function which will reverse the vowels in a string. Any characters which are not vowels should remain in their original position. Here are some examples:
function reverseVowels(str) {
  //I make several variables for this challenge. vow is an array of all the vowels both upper and lower case, this is to compare the letter in the given string.  count will be used to find the vowel indexes in srting.
  //arr is a copy of str.split that will be left along and used for switching vowels in str.  str i change into an array with all of the letters and elements split apart.
  var vow=["a","e","i","o","u","A","E","I","O","U"], count= new Object(), arr=str.split(""),str=str.split("");
  // here i use the map method to run through the str array and every time i find a vowel(using the vow array to check) i put that index number into the count object.
  str.map( function (c,i,a) { if (vow.indexOf(c)!=-1){return count[i]=i;} });
  // now i make two more variables.  x which is the count obj in array form, and y which is the same thing but reversed.  i will use these in the loop below
  var x=Object.keys(count), y=Object.keys(count).reverse();
  //here i make a for loop to switch the vowels.  i made the loop go half the length of x which is how many vowels there are in str. i  did this because i will be using y (wich is x reversed) and x together to switch the vowels so i only need to go half the lenght of each
  for (var i=0; i<x.length/2; i++){
    // each iteration of the loop i make use x and y as index's in the str array
    // in the first iteratoin i make the first vowel in str (which would be the first number in x) equal the last vowel (which is the last number in y as it is the revers of x). And vice versa using the arr array which is not changed at all so it equals the original str array.
    str[x[i]]=str[y[i]];
    str[y[i]]=arr[x[i]];
  }
  return	str.join("");
}
console.log(reverseVowels("Hello!")); // "Holle!"
console.log(reverseVowels("Tomatoes")); // "Temotaos"
console.log(reverseVowels("Reverse Vowels In A String")); // "RivArsI Vewols en e Streng"

//The DNA is a long sequence of either cytosine (C), guanine (G), adenine (A), or thymine (T) and their order is crucial for the transmission of genetic information. The reading of this sequence doesn't always happen from the start to the end, but there are some regions that need to be repeated. To do so, the organisms developed a system composed by “transcription factors”. A transcription factor is a molecule that binds to specific DNA sequence (binding sites), thereby controlling the number of repetitions of that sequence.
//Given these group of transcription factors and relative binding sites:
/*
ATF6: "TGACGT"
CREB: "TGACGCA"
cMyc: "CACGTG"
Gata1: "GATT"
AhR: "TGCGTG"		*/
//Write a function transFactors that takes the argument seq and returns the transcription factor(s) that bind and the binding position(s) in the sequence (starting from 1). The output should be an object containing an array of the name(s) of the transcription factor(s) and an array of the binding position(s).
//Please note that some transcription factors could have overlapping binding sites with others (or with themselves).
function transFactors(seq) {
  var x,y,z,outp={},ind={"ATF6":[],"CREB":[], "cMyc":[], "Gata1":[], "AhR":[]}, tf={"ATF6":"TGACGT","CREB":"TGACGCA", "cMyc": "CACGTG", "Gata1": "GATT", "AhR": "TGCGTG"};
  // i made several variables for this challenge.  x,y,z will be explained in the for loop.  outp means output and is what i will return.  ind is what i will put the index values in if any of the sequences match seq. and tf is what i will use to compare seq to.

  for (var i=0; i<seq.length; i++){	// this is a for loop running through the seq given.  i made the x,y,and z variables to make writting code easier incase i had to use them more than once, and to make it more readable.

    //these three variables are the length of characters in the tf object (the specific character sets were looking for) the start of each one is the character at i in this iteration of the loop and the next 5 character for x, next 3 characters for y, and next 6 for z.
    x=seq[i]+seq[i+1]+seq[i+2]+seq[i+3]+ seq[i+4]+seq[i+5];
    y=seq[i]+seq[i+1]+seq[i+2]+seq[i+3];
    z=seq[i]+seq[i+1]+seq[i+2]+seq[i+3]+ seq[i+4]+seq[i+5]+seq[i+6];

    for (var d in tf){//this is an inner for loop running through the tf object comparing x,y, and z to all of the sequences in tf.  if it finds a match it pushes that starting index into the match's array in the ind object.

      	if (x===tf[d]){ ind[d].push(i+1)};
      	if(y===tf[d]){ind[d].push(i+1)};
      	if(z===tf[d]){ind[d].push(i+1)};
    }// end of inner loop
  }//end of outer loop

  for (var x in ind){// this for loop goes through the ind object and checks the values(arrays) of each property, if their array length is at least one it pushes the property and value into the outp obj..  any factors that had a match will have at least one value in their array's.

    if (ind[x].length>=1){
    	outp[x]=ind[x]; }
  }//end of loop
  return outp;
}
seq = "ATGGCTGACGTCGTCATGGCGCCCCGATTGAACGATTCCTCCTCCT"
console.log (transFactors(seq));	//-->returns: { ATF6: [ 6 ], Gata1: [ 26, 34 ] }
console.log(transFactors("TGACGTGACGT")); //-->	{ ATF6: [ 1, 6 ] });
console.log(transFactors("TGCGTGCGTG"));//-->{ AhR: [ 1, 5 ] });

//A traveling salesman has to visit clients. He got each client's address e.g. "432 Main Long Road St. Louisville OH 43071" as a list.
//The basic zipcode format usually consists of two capital letters followed by a white space and five digits (OH 43071). The list of clients to visit was given as a string of all addresses, each separated from the others by a comma, e.g. :
//To ease his travel he wants to group the list by zipcode.
//write a function travel that will take two parameters r (list of all clients' addresses) and zipcode and returns a string in the following format:
//zipcode:street and town,street and town,.../house number,house number,...
//The street numbers must be in the same order as the streets where they belong.
//If a given zipcode doesn't exist in the list of clients' addresses return "zipcode:/"
function travel(r, zipcode) {
  r=r.split(","); // first i split the r string by the comma so i can work with each adress seperatly.

  var zi, arr=[],sn=[],x; // i made four variables for this challenge. zi would be the starting index of the zip code in each adress.  arr is where i put the addresses with the right zipcode to work on. sn is where i will put the home number of each address in arr.  x is what i will use to put the home numbers in sn.

  for (var i=0; i<r.length; i++){// in this loop I will compare each adresses zip code to find the right ones.  for this i use the zi to find the starting index of the zip code in each address. i put the riht ones into the arr array.

    zi=r[i].length-8;
    if (zipcode===r[i][zi]+r[i][zi+1]+r[i][zi+2]+r[i][zi+3]+r[i][zi+4]+r[i][zi+5]+r[i][zi+6]+r[i][zi+7]){
        arr.push(r[i]);}
  }// end of loop

  for (var i=0; i<arr.length; i++){// in this loop i mess with the arr array going through each address to return in the right way for the challenge.

    zi=arr[i].length-8;// i use zi again to help find the zip code in the address

  	arr[i]=arr[i].split(""); arr[i].splice(zi-1);arr[i]=arr[i].join("");
    //with the code above i split each address into the individual character.  then i get rid of the zip code at the end of each address and pop the white space at the end. Finally i put the address back together.

    arr[i]=arr[i].split(" "); x=arr[i].shift(); arr[i]=arr[i].join(" ");
    //in this line i once again split each address but this time i split it by white spaces keeping the words together. And as the firs index in this equals the house number i get rid of it in each element and put that into the x variable.  And then i join the address back together.

    sn.push(x);// here i push the house number that currently equals x into the sn array.
  }// end of loop

  if (arr.length===0){ return `${zipcode}:/`};	// here i check if any address had a zip code that matched, if none did then i returned the default answer

  return zipcode + ":" +(arr.join(",")) + "/" + sn.join(",");// here i join the zipcode, arr , and sn together to form my answer in the way required.
}
var r = "123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,786 High Street Pollocksville NY 56432"
console.log(travel(r, "OH 43071"))// --> "OH 43071:Main Street St. Louisville,Main Long Road St. Louisville/123,432"
console.log(travel(r, "NY 56432"))// --> "NY 56432:High Street Pollocksville/786"
console.log(travel(r, "NY 5643"))// --> "NY 5643:/"

//in this challenge you have to modify the toString method.  the new method should check if whatever number is given to it is prime.
//if the number is prime you should return the ads var below plus the number.  if it is not prime then return the number as a string.
var ads="\nNow is the time for advertisements:\n"+
"My name is myjinxin, 25 years old, Male, \n"+
"unmarried, handsome, rich, looking for\n"+
"a lovely woman as a life partner\n";
Number.prototype.toString=function(){
  var x = this
  for (var i=2; i<x; i++){	// this loop is used to find out if the number is prime

    if (this%i===0){ return x +""}
  }//end of loop

   if (x>1){return ads+x; }// this makes sure that the number (that should be prime at this point) is greater than 1

  else {return x + ""}
}
console.log((7).toString());
/*-->Now is the time for advertisements:
My name is myjinxin, 25 years old, Male,
unmarried, handsome, rich, looking for
a lovely woman as a life partner
7*/
(1).toString();
//-->1
nd

//Check if the elements of an array form an arithmetic progression or if the array contains a sequence of elements that form an arithmetic progression.
//If the entire array forms an arithmetic sequence, the function returns true. If it's not an arithmetic progression itself but it contains at least one, return the index of the element where the first arithmetic sequence starts. If it's not one itself and it doesn't contain any, return false.
//An arithmetic sequence will always consist of at least 3 numbers. If this condition is not satisfied, the function will return undefined.
//The function hasArithmProg takes a single parameter, arr, and can return a boolean, a number(the index) or undefined.
//An arithmetic progression is a sequence of numbers such that the difference between two consecutive terms is a constant quantity.
//e.g. 1, 2, 3, 4,... constant = 1 e.g. 9, 7, 5, 3,... constant = -2

function hasArithmProg(arr) {
  if (arr.length<3){ return undefined};	// here i check if the array has at least three elements in it, if it doesn't i return undefined

  var x=true,temp=arr[0]-arr[1];
  // i made three variables for this challenge.  x is set to true to start with and will be used in the firs loop.  temp is the value of the first index - the second and will also be used in the firs loop.

  for ( var i=0; i<arr.length; i++){// in this loop i check if there is an arithmetic sequence in the entire array. i made the temp variable because it has the value of the difference of the first two indexes.  every iteration of the loop i check to see if the current index minus the next index equals the temp variable (and i made sure that the test won't run on the last element.)
    								//if there is a sequence then every element minus the next should have the same value as temp. if the loop finds a break in the sequence then i make x equal false and break the loop.

   	if ( (i<arr.length-1) && temp != arr[i]-arr[i+1]){
      	x=false; break; }
  }// end of loop

  if (x===true){ return x};// here i check x is still true which it should only be if there is a sequence throught the entire array. if it is I return true.

  for (var i=0; i<arr.length; i++){// in this loop i check if there is a sequence with at least three elements in the array.  if there is i return the index at the starting point of that sequence.

    if (arr[i]-arr[i+1] === arr[i+1]-arr[i+2]){
      return i;}
  }// end of loop

  return x;// here i return x which is false. the function should only get this far if there is no sequence in the array.
}

console.log(hasArithmProg([9,5,1]))//, true);
console.log(hasArithmProg([9,1,2,14,46]))//, false);
console.log(hasArithmProg([90,2,4,6,8,14]))//, 1);
console.log(hasArithmProg([2,10,4,6]))//, false)
console.log(hasArithmProg([9,1]))//, undefined);

//Build a function sumNestedNumbers that finds the sum of all numbers in a series of nested arrays raised to the power of their respective nesting levels. Numbers in the outer most array should be raised to the power of 1.
function sumNestedNumbers(arr,pw) {
  if(pw===undefined) {pw=1};// for this challenge i created another parameter pw.  i set it equal to 1 if it is not alrady set when the function is called.

  var t=0;	//the t variable is the total that i will return
  for (var i=0; i<arr.length; i++){// i made a loop to go through and check every element of the array.

    if (Array.isArray(arr[i])){		// in this if statement it checks if the element is also an array. if it is an array then i use recursion to call this same function on that element increasing the pw by 1, and then i add that result to t.

      t+=sumNestedNumbers(arr[i], pw+1);
  		}
 	else {t=t+Math.pow(arr[i],pw)};		// if the element is not an array then it adds that element to the power of pw to t.

  };   //end of loop
  return t ;
}

console.log(sumNestedNumbers([1, [2], 3, [4, [5]]  ]))
//-->1 + 2*2 + 3 + 4*4 + 5*5*5 = 149


//"Every even integer greater than 2 can be written as the sum of two primes"---which is known today as the (strong) Goldbach's conjecture.
//Even though it's been thoroughly tested and analyzed and seems to be true, it hasn't been proved yet (thus, remaining a conjecture.)
//Your task is to implement the function in the starter code, taking into account the following:
/*  If the argument isn't even and greater than two, return an empty array.
    For arguments even and greater than two, return a two-element array with two prime numbers whose sum is the given input.
    The two prime numbers must be the farthest ones (the ones with the greatest difference)
    The first prime number must be the smallest one.		*/

function isPrime (num){// 	this function is to check if a number is prime

    for(var i = 2; i < num; i++) {
        if(num % i === 0) {
            return false;
        }
    }
    return num > 1;
}
function checkGoldbach (n) {
  if (n<=2 || n%2!= 0){ return []};	// first i made sure that the number is greater than 2 and not an even number

  if (n===4){ return [2,2]};	// i make this because four was the only number i could think of would return 2 like this.

  var out=[];
  for (var i=3; i<n; i+=2){// this outer loop goes through every odd number between 2 and n

    if (isPrime(i)){	// if the number is prime i use this inner loop

      for (var d=n-1; d>=n/2; d-=2){	//this inner loop looks for a number that is prime going from n to half of n.

        if (isPrime(d) && i+d ===n){	// if it finds a number that adds with i to equal n then it pushes those number into the out array and returns it.

          out.push(i), out.push(d);
          return out;
        }
      }// end of inner loop
  	}// end of if statement
  }// end of outer loop
  return out;	// if no two number were found that match the challenges conditions then the out array is returned empy.

}

console.log(checkGoldbach(2))// -->[]
console.log(checkGoldbach(5))// -->[]
console.log(checkGoldbach(4))// -->[2, 2]
console.log(checkGoldbach(6))// -->[3, 3]
console.log(checkGoldbach(14))// -->[3, 11]


//Can you mirror the properties on an object?
//Given an object with properties with no value
/*		abc: -
		arara: -
		xyz: -		*/
//Return a new object that have the properties with its mirrored key!
/*		abc: cba
		arara: arara
		xyz: zyx		*/
//"You cannot change the original object, because if you did that the reflection would change."

function mirror (obj) {
  var nob={};// i created this var nob (new object) to return as the answer

  for (var i in obj){	// in this for loop i go through each property in obj and set that property in nob and make it equal the reverse of that property

    nob[i]=i.split("").reverse().join("");	// to make the value the reverse i split it into individual characters, reverse them, and then join them together again.

  }
  return nob;
};


//Did you ever see the movie called Snakes on a Plane?
//In this Kata there are also snakes on a plane but now YOU can be the hero.
//Count how many snakes are on the plane
//Notes:
//    snakeskins are uniquely patterned with a single character per snake
//    snakes can be any length
// the array that is given to you will have other arrays as the elements (snakes).

function snakesOn(p) {
  var ar=[];	// i made this empy array to push in the letters (snakes) in

  for (var i=0; i<p.length; i++){	// this loop goes through every element in the given p array

    for (var d=0; d<p[i].length; d++){	// this inner loop goes through the array of each i element in the p array.

      if (p[i][d] != "_" && ar.indexOf(p[i][d]) === -1){	// this checks each element (d) firs to make sure that the element isn't "_" and then that the letter isn't already in the ar array.

        ar.push(p[i][d]);	// if the letter isn't in the ar array then i push that letter in ar.
      }	// end of if statement
    }	// end of inner loop
  }		// end of outer loop

  return ar.length;	// finally i check the length of the ar array as the number of snakes.
};

 var aPlane = [
        '_A_AAAAA__'.split(''),
        '_AA____AAA'.split(''),
        'D_AA_____A'.split(''),
        'DD_AAAAA_A'.split(''),
        '_D_____AAA'.split('')
      ]

console.log(snakesOn(aPlane));	//-->2


//all you have to do is determine whether the distances between any visiting cats in the yard are large enough to make for a peaceful afternoon, or whether there is about to be an altercation because they are too close and someone will need to deal with it.
//As input your function will receive a list of strings representing the yard, and an integer representing the minimum distance needed to prevent problems (considering the cats' current states of sleepiness). A point with no cat in it will be represented by a "-" dash. Lou, Mustache Cat, and Raoul will be represented by an upper case L, M, and R respectively. At any particular time all three cats may be in the yard, or maybe two, one, or even none.
//If the number of cats in the yard is one or none, or if the distances between all cats are at least the minimum distance, your function should return True/true/TRUE (depending on what language you're using),
//But if there are two or three cats, and the grid distance between at least two of them is smaller than the minimum distance, your function should return False/false/FALSE.
//the minimum distance is at 6 any less and there will be a cat fight
function peacefulYard(y, min) {
  	var c=[ "M", "L", "R"];	// this var is the cat names as they will appear in the y array.

    for (var i=0; i<y.length; i++){	// outer loop
      for (var d=0; d<y[i].length; d++){	// in this inner loop i check through each element in the y array for the cats (L, M or R).  if I find them then i put that gird spot (i,d) in the c array in place of that cat's name.

        if (c.indexOf(y[i][d]) != -1){
         c[c.indexOf(y[i][d])]= [i,d];}

      }	// end of inner loop
    }	// end of outer loop

  	// in these dis var i find the grid difference between two of the cats in the c array, if there wasn't a particular cat in the y array then the dis var will be a NAN.
  var dis1= Math.sqrt( Math.pow( (c[0][0] -c[1][0]),2) + Math.pow( (c[0][1] -c[1][1]),2) ),
      dis2= Math.sqrt( Math.pow( (c[1][0] -c[2][0]),2) + Math.pow( (c[1][1] -c[2][1]),2) ),
      dis3= Math.sqrt( Math.pow( (c[0][0] -c[2][0]),2) + Math.pow( (c[0][1] -c[2][1]),2) ),
  	  ar=[dis1,dis2,dis3];	// and this var is the dis in an array.

  	for (var i=0; i< ar.length; i++){	// in this loop i check the distances between any cats in the yard is at least the min distance, otherwise i return false.

      if (ar[i] <min){ return false;}
    }
  return true;
}

var one=["------------",
 "------------",
 "-L----------",
 "------------",
 "------------",
 "------------"]; min dis= 10

var two=["------------",
 "---M--------",
 "------------",
 "------------",
 "-------R----",
 "------------"];	// min dis=6

var three=["-----------L",
 			"--R---------",
            "------------",
 			"------------",
 			"------------",
 			"--M---------"];  //min dis= 4
console.log(peacefulYard(one,10));	//--> true
console.log(peacefulYard(two,6));	//--> false
console.log(peacefulYard(three, 4));	//-> true


//In this Kata, you need to simulate an old mobile display, similar to this one:
/*  ***************************
    *                         *
    *                         *
    *        CodeWars         *
    *                         *
    *                         *
    * Menu           Contacts *
    ***************************		*/
//Input Parameters:
//    number of characters for width (n)
//    height-to-width ratio in percentage (p)
//Example: if n=30 and p=40, then display will be 30 characters long and its height will be 40% of n(12 characters in this case).

//Rules and Notes:
/*  the border, as you can see, is filled with *;
    the rounding of divisions and float numbers is always by the integer (1.2, 1.5, 1.9 they are always reduced to 1), keep this in mind when you calculate proportions
    the menus Menu and Contacts are always in the second last line, at 1 character distance respectively from the left and from the right border;
    the CodeWars logo is always in the middle horizontally and in the half-1 line vertically;
    	the width n must be always at least 20 characters and the percentage p must be always at least 30%, take care of this (otherwise menus won't likely fit).
    random tests might get big and percentages might be higher than 100;	*/

function mobileDisplay(n,p){
  p= Math.floor((n*p)/100);	// this sets the p variable to be the p percent of n rounded down to the nearest whole integer.

  var s="", space="*", end="", med="", m="* Menu", c="Contacts *\n", ls=n-16, ms=Math.floor((n-10)/2-1);

  for (var i=0; i<=ms; i++){	// this loop sets the number of spaces required for the medium line with codewars in it.  the spaces are are on both sides of the word codewars, so the med var will be half that number of spaces.

    med+=" ";
  };	// end of loop

 	 // these two if and else statements are to test if the n is odd, because then that would make the necessary spaces on the sides of codewars be uneven.  if it is odd then i add an extra space on the right side.
  if (n%2!=0){ med=( "*" + med + "CodeWars" + med + " *\n") }
  else {med=( "*" + med + "CodeWars" + med + "*\n") }


  for (var i=0; i<n; i++){	// this loop sets the number of * in the s and end var equals to n, and the number of white spaces between the *'s in the middle lines necessary.

    end+="*";
    s+= "*";

    	// this if statement checks for the last iterationof the loop.  if it is then after it changes the end and s var it adds a * at the end of the space var instead of a white space. and then it breaks the loop.
    if (i===n-1){space=space.split(""); space.pop();
                 space=space.join(""); space +="*";
                 s+="\n"; break;}	// end of if statement
    space+= " ";
  }	// end of lop

  for (var i=0; i<p-3; i++){	// this loop to add the lines in the middle of the boxes (ex: *       *\n) with the exception of the middle line that has code wars and the second to last line with Menu and contacs in it and the very last line.

    if (i===Math.floor(p/2-2)){s+=med;continue;}	// this if statement checks if the line about to be made is the middle of the box, if it instead adds the line with the codewars in it.

  	s+=space; s+="\n";
  }	// end of loop

  s+=m;	//this adds the m var ("* Menu") the beginning of the second to last line

  for (var i=0; i<ls; i++){	// this loop adds the number of white spaces necessary between menu and contact

    s+=" ";
  }	// end of loop

  s+=c;	// this adds the end of the second to last line.  the "Contacts *\n"

  s+=end;	//this adds the last line which is the same as the very first.

  return s
}

//Examples:
//    mobileDisplay(30,40):	-->
/*  ******************************
    *                            *
    *                            *
    *                            *
    *                            *
    *    (10)  CodeWars          *
    *                            *
    *                            *
    *                            *
    *                            *
    * Menu(5)  (14)  (9)Contacts *
    ******************************	*/

//		mobileDisplay(25,50):-->
/*    *************************
      *                       *
      *                       *
      *                       *
      *                       *
  (6) *(7) (8)CodeWars    (7) *
      *                       *
      *                       *
      *                       *
      *                       *
      * Menu         Contacts *
      *************************		*/


//You'll have to translate a string to Pilot's alphabet (NATO phonetic alphabet) wiki.
//Ex---Input: If you can read
//Output: Indian Foxtrot Yankee Oscar Uniform Charlie Alfa November Romeo Echo Alfa Delta
//    Keep the punctuation, and remove the spaces.
//    Use Xray without dash or space.
function to_nato(w) {
  		//first i made s as an empy array var, this is what i will put the translations into. And then i made the object alp with has all of the NATO phonetic alphabet with the corresponding Letter in upper case.

  var s=[],alp={ "A":"Alfa","B":"Bravo", "C":"Charlie","D":"Delta","E":"Echo","F":"Foxtrot",
           "G":"Golf","H":"Hotel","I":"India","J":"Juliett","K":"Kilo","L":"Lima",
           "M":"Mike","N":"November","O":"Oscar","P":"Papa","Q":"Quebec","R":"Romeo",
           "S":"Sierra","T":"Tango","U":"Uniform","V":"Victor","W":"Whiskey",
           "X":"Xray","Y":"Yankee","Z":"Zulu"  };

  w=w.toUpperCase().split(" ").join("").split("");	// here i made every letter in w uppercase so find them in the alp object.  and then i split the phrase into an array by space, then i joined it all togther to make 1 word which gets rid of all white spaces.  and finally i split it into indiviual letter.

  for (var i=0; i<w.length; i++){	// in this loop i am checking if each character is a letter or not

    		// if the character is a letter then i push that NATO tranlation into the s array.
    if (alp[w[i]]!=undefined){
      s.push(alp[w[i]]);
    }

    		//if the character isn't a letter (which whould only be punctuation of some kind or commas) then i push it straight into the s array.
    else{ s.push(w[i])}

  }	//end of loop
  return s.join(" ");
}
console.log(to_nato(i));


//Given n representing the number of floors build a beautiful multi-million dollar mansions like the ones in the example below:
function myCrib(n) {
  var r="/",roof="",roofwall="",inSpace="", outSpace= (n*2), wall="|", house="|", floor="|";

  for (var i=0; i<outSpace; i++){		//this loop is to maket the necessary spaces between the walls, floor, and bottom of the roof where it touches the house (r).
    r+="_";
    wall+=" ";
    house += " ";
    floor+="_";
  }		// end of loop

  r+="\\";  house += "|"; wall +="|"; floor+="|";		// this line adds the other side to these variables, the other wall

  		//this part is to set up the walls and floor.
  for (var i=0; i<n-2; i++){	// this loop is to expand the walls up and down, to make the full house except the roof and floor;
   wall+= "\n"+ house;
  }		//end of loop

  if (n>1){ wall = wall +"\n" + floor;}	// this is to set the floor and wall together.  if the house is only 1 level i skip this part as just the floor level is enough.
  else { wall=floor;}

  		// this part below is to set up the rest of the roof
  outSpace=n-1;
  for (var i=0; i<n; i++){			// these two loops are to make the majority of the roof with the exception of where it touches the house, which is already made with r .

    for (var d=0; d<=outSpace; d++){	// this inner loop uses the outSpace variable set just before this loop as it's limit.  this is to set the space on the sides of the roof to level it with the rest of the house to make a triagle.
      roofwall+=" ";
    }	// end of inner loop

    outSpace -=1;		// this increments the outSpace var down by 1 to keep the house walls going down proportionalty like the sides of a triagle.

    roof= roof+ roofwall+ "/"+ inSpace+ "\\" + roofwall+ "\n";		//here i add the roofwall with the /, inSpace (which is the space inside the roof between the / and \), \, and \n to make a full level of the roof.

    roofwall=""; inSpace+="  ";		// here i set the roofwall back to blank to start the next level to add onto the roof var, and i also add two spaces to the inSpace var to make the next level proportionate.
  }

  return roof+ r+"\n"+ wall;
}

/*   /\		(8 splaces of line across this house (n *2)+2
    /  \	8 lines up and down
   /    \
  /______\  // number of floors 3		(bottom of roof has 6 spaces(_) between the /\
  |      |
  |      |
  |______|
     /\			6 spaces across (n*2)+2
    /  \
   /____\
   |    |   // 2 floors
   |____|
     /\
    /__\    // 1 floor
    |__|						*/
console.log(myCrib(3));
console.log(myCrib(2));
console.log(myCrib(1));


//Given an array as an argument complete the function countSmileys that should return the total number of smiling faces.
//Rules for a smiling face:
/*-Each smiley face must contain a valid pair of eyes. Eyes can be marked as : or ;
  -A smiley face can have a nose but it does not have to. Valid characters for a nose are - or ~
  -Every smiling face must have a smiling mouth that should be marked with either ) or D.	*/
//Valid smiley face examples:
//	:)  :D  ;-D  :~)
//Invalid smiley faces:
//	;(  :>   :}   :]

function countSmileys(arr) {
	var t=0, smiles=[":)",";)",":D",";-D",":~)",":-D",";D",":-)",";~)",";~D"];
  arr.filter(function (c,i,a){ c=c.replace(/\s+/g,"");if (smiles.indexOf(c) != -1){return t+=1;} } )
  return t;
}
console.log(countSmileys([':)', ';(', ';}', ':-D']));       // should return 2;
console.log(countSmileys([';D', ':-(', ':-)', ';~)']));     // should return 3;
console.log(countSmileys([" ;~( "," ;D "," :> "," ;-D "," :o) "," :~) "," :)"])); // should return 4

//this is another version
/*function countSmileys(arr) {
	var t=0;
  arr.filter(function (c,i,a){ c=c.replace(/\s+/g,"");c=c.split("");
                              if ( (c[c.length-1] === ")" || c[c.length-1]==="D")
                              && c[c.length-2]!= "o")   { return t+=1;} } )
  return t;
}	*/


this is another version of the code
function countDays(d){
  var today = new Date(), tdarr=[], d8arr=[], daysLeft, currentMonthDays, dMonth, tot_days=0, leapYearDay=0, difvar=2020,
      daysLeft=[[1,31],[2,28],[3,31],[4,30],[5,31],[6,30],[7,31],[8,31],[9,30],[10,31],[11,30],[12,31]	];

  tdarr[0]= today.getMonth(); d8arr[0]=d.getMonth();		//these three lines are to set up the tdarr(today) and d8arr (date given-d) arrays so it's Month, day, year.
  tdarr[1]= today.getDate();	d8arr[1]= d.getDate();
  tdarr[2]= today.getFullYear();	d8arr[2]= d.getFullYear();

  if (tdarr.join(" ")=== d8arr.join(" ")){ return "Today is the day!"}	//this line checks if the dates are the same

  		//these three lines are to check if d is in the past by checking it against today's date by checking the year, then month, and then day
  if (tdarr[2]>d8arr[2]){ return "The day is in the past!"}		//this checks year
  else if (tdarr[2]===d8arr[2] && tdarr[0]>d8arr[0]){ return "The day is in the past!"}		// checks month
  else if (tdarr[2]===d8arr[2] && tdarr[0]===d8arr[0] && tdarr[1] >d8arr[1]){ return "The day is in the past!"}		//checks day

  dMonth=d8arr[1]		//this var is the days in the month of d that have passed.
  currentMonthDays= daysLeft[tdarr[0]][1]-tdarr[1];	// these two lines are to find how many months are left in the Current month (ex: if taday is jan 29th, then there would be 3 days left in jan.)
    if (currentMonthDays===0){ currentMonthDays= daysLeft[tdarr[0]][1]}; // this line checks if the currentMonth var is equal to zero which should only happen if the curren date given is the last day of that month, in this case i make currentMonthDays equal that months total days.

  if (tdarr[2] ===d8arr[2] && tdarr[0]===d8arr[0]){ return `${d8arr[1] -tdarr[1]} days`}		//this checks if the d given is in the same month as the current month but still in the future, in that case it returns the difference in days.

  for (var i=(tdarr[0]+1); i<(d8arr[0]); i++){	// this loop goes through every month between todays date (td) and the date given (d) (but not those two months) and adds all of the days of those months to the var tot_days
      tot_days +=daysLeft[i][1];
    }	//end of loop

    tot_days += (dMonth+currentMonthDays);	// now i add the differences between how many days are left in the td and d months to the tot_days var.  in this case there are 13 days left in jan and the full 28 days left to get the the d day given.  so 41 days are left between the two dates

  if (tdarr[2]<d8arr[2]){ tot_days +=(365 * (d8arr[2]-tdarr[2])) }		// this line is to add the total number of years (times 365) d is greater than today

  for (var i=2021; i<=d8arr[2]; i+=4){		// this loop is to add a day to the tot_days for each leap year between today and t
    leapYearDay +=1;
    if (difvar + 95.6 < i){ leapYearDay -=1;	difvar=i;}
  }
  tot_days+= leapYearDay;
  //if (d8arr[2] >2019 && d8arr[2]< 2026){ tot_days-=1}

  return `${tot_days} days`;
}
console.log (countDays(new Date("February 28, 2017")))  //-->


//this is another version of the smiles challenge 2 challenges above this.
//apparently there were a few instances of my code not working.

//Given an array as an argument complete the function countSmileys that should return the total number of smiling faces.
//Rules for a smiling face:
/*-Each smiley face must contain a valid pair of eyes. Eyes can be marked as : or ;
  -A smiley face can have a nose but it does not have to. Valid characters for a nose are - or ~
  -Every smiling face must have a smiling mouth that should be marked with either ) or D.	*/
//Valid smiley face examples:
//	:)  :D  ;-D  :~)
//Invalid smiley faces:
//	;(  :>   :}   :]

function countSmileys(arr) {
	var t=0, smiles=[":)",";)",":D",";-D",":~)",":-D",";D",":-)",";~)",";~D",":~D",";-)"];
  					//the smiles array contains every smile that i found in the test cases, i will use this to compare the arr given.
  arr.filter(function (c,i,a){ c=c.replace(/\s+/g,"");if (smiles.indexOf(c) != -1){return t+=1;} } )	//this filters each element of the arr array and checks if that element is in the smiles array, if it it it adds 1 to t.

  return t;
}

console.log(countSmileys([':)', ';(', ';}', ':-D']));       // should return 2;
console.log(countSmileys([';D', ':-(', ':-)', ';~)']));     // should return 3;
console.log(countSmileys([" ;~( "," ;D "," :> "," ;-D "," :o) "," :~) "," :)"])); // should return 4

here is a version of the code above using regular expression
function countSmileys(arr) {
	var t=0;		// this var will be the total number of smiles found
  arr.forEach(function (c,i,a){ if (c.match (/[:;][-~]?[)D]/gi) ){ return t+=1} } )	//this filters each element of the arr array and checks if that element is a smile using regular expression to check, if it is it adds 1 to t.

  return t;
}


//Validate all numbers to make local calls from the capital city at the Mexican United States.
//The first two digits are the lada. Lada can only be 55 or 56 for those Mexico City phone numbers.
//Valid numbers:
/*  (56) 84 65 52
    (56) 84 6552
    (56) 846552
    (56)846552
    56 84 65 52
    56 84 6552
    56 846552
    56846552
    55 95 64 85
    55 95 6485
    55 956485
    55956485		*/
//Non-Valid numbers:
/*  99956485
    abcdefgh
    (56) 84 6 552	*/

var isValidMXPhoneNumber = function(str) {
  var l=0, r=0, s;
  for (var i=0; i<str.length; i++){
	if (str[i]==="(") { l +=1; }
    if (str[i]===")") { r +=1;}
  }
  if (l!=r) { return false}
  s=str.replace ("(","");	s=s.replace (")","");		// this line is to remove the parenthesis in str.

  if (s[0] + str[1] != "55" && s[0] + s[1] != "56"){ return false}
  if (s.replace(/\s/gi,"").length != 8){ return false}	//these two lines are to make sure that the first numbers are 55 or 56 and that there are only 8 character in total.

  if ( str.match(/(\(*?\d\d\)*? \d\d \d\d \d\d)/ ) || str.match(/(\(*?\d\d\)*? \d\d \d\d\d\d)/) ||
       str.match(/(\(*?\d\d\)*? \d\d\d\d\d\d)/)   || str.match(/(\(*?\d\d\)*?\d\d\d\d\d\d)/)  ){ return true}
  else { return false}
  return false;
};

console.log(isValidMXPhoneNumber( "(56)) 84 65 52"));//--> true
console.log(isValidMXPhoneNumber(  "(56) 846 552"));//--> false


//Given some text, count each alphabetic character's occurrence in it, regardless of the case.
//Let's suppose you have to use an old terminal window to represent the occurrencies of each character in a text-based horizontal bar graph. The terminal has a maximum width, provided as parameter (max_units_on_screen), and you have to abide by it.
//For example, if the maximum width is 80, your longest bar in the graph will be scaled to this size and all the others have to be represented and scaled proportionally to this size. Every unit of the bar will be represented by the character #. See examples below for typical output format.
//The bars of the graph have to be sorted by number of occurrencies (from biggest to lowest, before getting scaled), then by alphabetic order of the letter (from a to z). Approximation of decimal numbers will happen on the lowest integer (for example: 57.1, 57.2, 57.68, 57.999 will all get reduced to 57 )
//Input:	count_and_print_graph("just a short text", 4)
//Output:
/*      t:####		4
        s:##		2
        a:#			1
        e:#
        h:#
        j:#
        o:#
        r:#
        u:#
        x:#			*/

//Input:	count_and_print_graph("just a short text", 23)
//Output:
/*  t:#######################	(23)		(23/4=5.75)
    s:###########		(11)	2* 5.75 math.floor
    a:#####		(5)	1* 5.75 math.floor
    e:#####
    h:#####
    j:#####
    o:#####
    r:#####
    u:#####
    x:#####				*/
function countCharsBarGraph(text, maxw) {
  var alp={ a:0, b:0, c:0, d:0, e:0, f:0, g:0, h:0, i:0, j:0, k:0, l:0, m:0, n:0, o:0, p:0, q:0, r:0, s:0, t:0, u:0, v:0, w:0, x:0, y:0, z:0},
      obj={}, max=0, max1=0, comp=0, str, retStr="";

  text=text.replace(/\s/gi,""), text=text.toLowerCase();		// this line gets rid of all of the white spaces in text and changes all letters to lower case

  for (var i=0; i<text.length; i++){	//this loop adds 1 to the letter in alp every time it finds that letter in text
    alp[text[i]]+=1;
  }		//end of loop

  for (var i in alp){
    if (alp[i]>max){ max = alp[i], max1=alp[i]}
  }
  //max=Object.values(alp).sort(function (a,b) { return b-a})[0];		//this makes the max var equal the largest number in the alp object, which will equal the letter that appears the most in text.

  while (max>0){		//this while loop combined with a foor loop puts the letters in text into the obj var with their corresponding numebers in order of largest to smallest and them in alphabetical order after size.

    for ( var i in alp){
      if (alp[i]===max){
        obj[i]=max; }
    }
    max-=1;
  }			// end of while loop


  max= max1;//	Object.values(alp).sort(function (a,b) { return b-a})[0];		// here i make max eqaul the top number in the alp obj again.

  str="#".repeat(maxw);			// this line makes a string of # the length of maxw
  comp= (maxw/max);				// this line is to make the comp var (comparison) equal to maxw divided by the biggest number in obj.  this will be used to change the other letter proportionaltely

  for ( var i in obj){			// this loop  makes each letter in obj equal the number of # in str instead of the number itself.

    obj[i]=str.slice(0, Math.floor( comp *obj[i]) );
  }			//end of loo p

  for (var i in obj){		//this loop puts the obj keys and values into a string format with \n between them

    retStr+= `${i}:${obj[i]}\n`;
  }		// end of loop

  retStr=retStr.split(""); retStr.pop(); retStr=retStr.join("");
  return retStr;
}

console.log(countCharsBarGraph ("just a short text", 23) );
/*-->
	t:#######################
    s:###########
    a:#####
    e:#####
    h:#####
    j:#####
    o:#####
    r:#####
    u:#####
    x:#####		*/


//I haven't fully figured out this code and it is very time consuming as a code so it needs improvement.  The next intery will be a shorter version i learn.

//You will be given a two-dimensional array such as the one below.
/*	a =[
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [1, 2, 3, 4, 5, 6, 7, 8, 9],
        [1, 2, 3, 4, 5, 6, 7, 8, 9]
      ]			*/
//Remove all even integers from each sub-array.
//Sum the remaining odd integers of each sub-array.
//Sum of odds ( a[0] = 1 + 3 + 5 + 7 + 9 ) = 25
//Find the Least common multiple of the arrays.

/*(25, 25, 25, 25, 25, 25, 25, 25, 25)
  ^                                ^
  |                                |
 a[0]-----------------------------a[8]	*/
//example : lcm( 25, 25, 25, 25, 25, 25, 25, 25, 25 ) = 25
//example : lcm( 37, 29, 19, 38, 31, 28, 15, 24, 9 ) = 1592632440
//Integers are between 0 and 9. Sub-array size is always 9. The number of sub-arrays varies between 9 and 18.

function kiyoLcm(a) {
  var r, d=0;
  for (var i=0; i<a.length; i++){

     a[i]= a[i].filter( function (c,i,a){ return (c %2 != 0 && typeof(c) === "number") } );  	// this line runs through each sub array and only returns elements that are odd numbers

    if (a[i].length===0){  return 0}		// this checks if any of the elements left are empty arrays and if it is it returns 0.

    if (a[i].length >=1) {		// this if statement adds up the sum of each of the sub-arrays as long as they have at least one element

     a[i]= a[i].reduce(function ( t, c){ return t+=c} );
    }		// end of if statement

  }			// end of loop

        // this starts the calculation of finding the LCM with the the a array. to do this i use the gcd function below
  		// to find the lcm of two number i will be using the formula ( num1 *num2)/ gcd(num1, num2).
  r= ( a[0] * a[1])/ gcd(a[0], a[1]);	// this sets the r var as the LCM of the first two elements of a to get r set for the loop.

  for (var i=2; i<a.length; i++){		// this loop starts on the third elment of a because i already used the first two to make r.  each iteration r is set as num1 in the formula I am using.

   r= ( r* a[i])/gcd( r, a[i]);
  }		// end of loop

  return r
}

function gcd (a,b){
  var arr=[2,a], ar=[2,b], max;

  if (a>b){ max=a}
  else { max=b}		//these two lines check for whichever number is bigger between a and b and sets that as the max var.

  for (var i=3; i<max/2; i++){		// this loop checks if i evenly divides into a/b and if it does then it pushes i into arr(a) / ar(b).

    if (a%i===0){ arr.push(i)}
    if (b%i===0){ ar.push(i)}
  }			// end of loop
  arr=arr.sort( function (a,b) { return b-a} );
  ar=ar.sort( function (a,b) { return b-a} );// these two lines sorts the ar and arr arrays from biggest to smalles
  for (var i=0; i<arr.length; i++){		// this loop checks if the arr element at index i is in ar.  And because the arrays are biggest to lowest the first number it finds that matches this is the biggest common divisor

    if (ar.indexOf(arr[i])!=-1){ return arr[i]}
  }// end of loop
}

console.log(kiyoLcm ([ [], [], [], [], [], [], [], [], [] ]));
	//--> 0
console.log(kiyoLcm ([  [9, 4, 5, 8, 0, 9, 1, 1, 3], [5, 0, 8, 5, 4, 3, 4, 5, 5], [9, 5, 1, 6, 7, 8, 8, 9, 5],
     [9, 9, 7, 8, 6, 2, 0, 2, 9], [4, 7, 9, 3, 6, 6, 2, 6, 1], [0, 3, 5, 7, 0, 5, 1, 6, 2],
     [7, 8, 4, 1, 0, 1, 6, 0, 0], [0, 2, 1, 8, 8, 7, 6, 0, 1], [4, 3, 5, 6, 5, 4, 0, 3, 6]   ]));
		//-->1,970,640);
console.log(kiyoLcm ([  [1, 1, 5, 4, 4, 2, 5, 1, 5], [4, 2, 3, 5, 1, 4, 4, 2, 5], [4, 2, 1, 4, 5, 5, 4, 3, 3],
     [2, 1, 5, 1, 1, 1, 1, 2, 4], [5, 1, 3, 1, 3, 2, 4, 2, 1], [3, 1, 1, 2, 4, 2, 5, 3, 5],
     [5, 2, 5, 3, 3, 4, 3, 4, 1], [3, 4, 4, 5, 5, 5, 5, 4, 5], [3, 3, 5, 5, 3, 3, 3, 5, 2]  ]));
console.log( (25*25)/gcd(25,25));
//-->21,420


//you will be given two strings containing only the characters "!" and "?" in any order and amount.  you have to check each string with the following rules.
//Each exclamation mark weight is 2; Each question mark weight is 3. Put two string left and right to the balance, Are they balanced?
//If the left side is more heavy, return "Left"; If the right side is more heavy, return "Right"; If they are balanced, return "Balance".

function balance(l,r){
  var lb=0, rb=0;

  for (var i=0; i< (l.length>r.length ? l.length : r.length); i++){		// this loop goes through both l and r checking each character to see if it is a ! or ? and then adding the right amount to lb (left balance) and rb(right balance).  Because i wasn't sure whether L or R would have a longer length i used a terenary operator to set the limit on the loop.

    if (l[i]==="!") { lb +=2}
   	else if (l[i]==="?") { lb +=3};

    if (r[i]==="!") { rb +=2}
    else if (r[i]==="?") { rb +=3}
  }		// end of loop

  if (lb>rb){ return "Left"}
  if (lb<rb){ return "right"}
  else { return "Balance"}
}

console.log(balance("!!","??"))// === "Right"
console.log(balance("!??","?!!"))// === "Left"
console.log(balance("!?!!","?!?"))// === "Left"
console.log(balance("!!???!????","??!!?!!!!!!!"))// === "Balance"

//here is a shorter version of the funciton above using the reduce method.

function balance(l,r){
  l=[...l].reduce (function (t,c) { return t+= (c==="!"? 2 :3 )},0 );
  r=[...r].reduce (function (t,c) { return t+= (c==="!"? 2 :3 )},0 );

  if (l>r){ return "Left"}
  if (l<r){ return "right"}
  else { return "Balance"}

}


//You are given a string of n lines, each substring being n characters long: For example:
//		s = "abcd\nefgh\nijkl\nmnop"	--	4 lines/ 4 letters in each line

//We will study some transformations of this square of strings.
/*  Symmetry with respect to the main cross diagonal: diag_2_sym (or diag2Sym or diag-2-sym)
	   -diag_2_sym(s) => "plhd\nokgc\nnjfb\nmiea"
			-->it basically adds a letter from each substring at (n) to each new sub string, then reverses the entire string
            	--> so the last string has the first letters of each original subtring in reverse order  (m i e a)
    Counterclockwise rotation 90 degrees: rot_90_counter (or rot90Counter or rot-90-counter)
	    rot_90_counter(s)=> "dhlp\ncgko\nbfjn\naeim"
			--> it adds a letter from each original substring at (n) into the new substrings, and reverses the order of the subtrings.
            	-->it does the same thing as the last function without reversing the new substrings themselves.
    selfie_diag2_counterclock (or selfieDiag2Counterclock or selfie-diag2-counterclock) It is initial string + string obtained by symmetry with respect to the main cross diagonal + counterclockwise rotation 90 degrees .
	    s = "abcd\nefgh\nijkl\nmnop" -->
    	    "abcd|plhd|dhlp (\n) efgh|okgc|cgko (\n) ijkl|njfb|bfjn (\n) mnop|miea|aeim"
        		spaces added to make it easier to see.
			--> it combines the original string with the strings made from the previous two function.
            	--> the [0] substring of each is combined into one sperated by a |.

		selfie_diag2_counterclock  printed with console log.
              abcd|plhd|dhlp
              efgh|okgc|cgko
              ijkl|njfb|bfjn
              mnop|miea|aeim			*/
//Task:  Write these functions diag_2_sym, rot_90_counter, selfie_diag2_counterclock and
// high-order function oper(fct, s) where
//        fct is the function of one variable f to apply to the string s (fct will be one of diag_2_sym, rot_90_counter, selfie_diag2_counterclock)
function diag2Sym(s) {
    var r=[], string=""; s= s.split("\n")	// here i made an empty array to put my new substrings into, a string array to be the new subtrings, and I split up the given string (s) to make it easier to work with.

  	for (var i=0; i<s.length; i++){		// this outer loop is to make the place of the new subtrings (in reverse order to how the answer is goint to be)

      for (var d=s.length-1; d>=0; d--){	//this inner loop goes backward from the last subtring to the first adding a letter from each one at positon (i) to the string var.

        string += s[d][i];
      }		// end of inner loop

      r[i]= string;
      string="";	// these two lines are to add the string var to the r array and then reset string back to blank
    }	// end of outer loop

      r= r.reverse();	// here i flip the r array putting it in the right order for the answer.
  return r.join("\n");
}

function rot90Counter(s) {
  // this function is the same as the one above except that the inner loop doesn't go backwards so the substrings themselves aren't reversed

    var r=[], string=""; s=s.split("\n");
  for (var i=0; i<s.length; i++){
    for (var d=0; d<s.length; d++){
      string += s[d][i];
    }
    r[i]=string;
    string="";
  }
  return r.reverse().join("\n");
}
function selfieDiag2Counterclock(s) {
  	//this takes the result from the previous two funciton into two variables split into arrays.
  var s1=diag2Sym(s).split("\n"), s2= rot90Counter(s).split("\n"),s=s.split("\n"), string="";

  for (var i=0; i<s.length; i++){	// this loop adds the element at [i] from s, s1, and s2 into one line seperated by "|" and adds"\n" to the end of each line except the last

    string =string+ s[i]+ "|" +s1[i] +"|" + s2[i];
    if (i<s.length-1){ string +="\n" }
  }		// end of loop

  return string
}

function oper(fct, s) {
    return fct(s);
}


var s = "abcd\nefgh\nijkl\nmnop";
//oper(diag_2_sym, s) => "plhd\nokgc\nnjfb\nmiea"
//oper(rot_90_counter, s) => "dhlp\ncgko\nbfjn\naeim"
console.log(oper(selfieDiag2Counterclock, s))// => "abcd|plhd|dhlp\nefgh|okgc|cgko\nijkl|njfb|bfjn\nmnop|miea|aeim"


//console.log(diag2Sym (s));
		/*-->	plhd
                okgc
                njfb
                miea		*/
//console.log( rot90Counter(s));
	/*--"dhlp
    	 cgko
         bfjn
         aeim"	*/
//console.log(selfieDiag2Counterclock(s));
		/*-->	abcd|plhd|dhlp
                efgh|okgc|cgko
                ijkl|njfb|bfjn
                mnop|miea|aeim	*/


//Teemo has a really big passion about programming and he want's to be productive till midnight. He want's to know how many minutes he has left to work on his new project.
//He doesn't want to look on the clock all the time, so he thought about a function, which returns him the number of minutes.
//Can you write him a function, so he can stay productive?
//The function will take a date object as parameter. Return the number of minutes in the following format:
	//"x minute(s)"
//You will always get a date object with of today with a random timestamp.
//You have to round the number of minutes.
//Milliseconds doesn't matter!
var dat = new Date(new Date().setHours(23,0,50,0));

function minutesToMidnight(d){
  var h=d.getHours(), m=d.getMinutes(), s=d.getSeconds(), t=0;
  if (h<12){ h+=12; t += (12*60)}
  while (h<23){
    t+=60;  h+=1;
  }
  t+= (60-m);
  if (s!=0 && s>30){ t-=1}

  if (t===1){ return `${t} minute`}
  return `${t} minutes`
}

console.log(minutesToMidnight(new Date(new Date().setHours(10,0,0,0))));// => "840 minutes"
console.log(minutesToMidnight(new Date(new Date().setHours(23,59,0,0)))); // => "1 minute"


//The purpose of this series is developing understanding of stastical problems in AS and A level maths. Let's get started with a simple concept in statistics: Mutually exclusive events.
//The probability of an OR event is calculated by the following rule:
///				P(A || B) = P(A) + P(B) - P(A && B)
//The probability of event A or event B happening is equal to the probability of event A plus the probability of event B minus the probability of event A and event B happening simultaneously.
//Mutually exclusive events are events that cannot happen at the same time. For example, the head and tail results of a toin coss are mutually exclusive because they can't both happen at once. Thus, the above example for a coin toss would look like this:
//				P(H || T) = P(H) + P(T) - P(H && T)
//Note that the probaility of tossing a coin and the result being both head and tails is 0.
//				P(H || T) = (0.5) + (0.5) - (0) P(H || T) = 1
//Thus the probability of a coin toss result being a heads or a tails is 1, in other words: certain.
//Your task:
//You are going to have to work out the probability of one roll of a die returning two given outcomes, or rolls. Given that dice rolls are mutually exclusive, you will have to implement the above forumala. To make this interesting (this is a coding challenge after all), these dice are not fair and thus the probabilites of receiving each roll is different.
//You will be given a two-dimensional array containing the number each of the results (1-6) of the die and the probability of that roll for example [1 , 0.23] as well as the two rolls for example 1 and 5.
//Given the two roll probabilities to calculate, return the probability of a single roll of the die returning either. If the total probability of the six rolls doesn't add up to one, there is a problem with the die; in this case, return null. Return your result as a string to two decimal places.
//Example below:
/*      1 : 1/6
        2 : 1/6
        3 : 1/6
        4 : 1/6
        5 : 1/6
        6 : 1/6			*/
//If asked for the rolls 1 and 2 then you would need to sum the probabilities, both 1/6 therefore 2/6 and return this. As above, you will need to return it as a decimal and not a fraction.

function mutuallyExclusive(d, r1, r2){
   d=d.sort(function (a,b){ return a[0]-b[0]});		// this is to sort the d array into ascending order based on the number at the 0 position of each sub array

  var t=0;
  for (var i=0; i<d.length; i++){		// this loop is to check if every roll's probability added up equal 1 which it is supposed to.

    t+= d[i][1];
  }		// end of loop

  if (t !=1){ return null};			// if the rolls added up don't equal 1 then I return null as the dice is messed up.

  return  (d[r1-1][1] + d[r2-1][1]).toFixed(2);
}

console.log(mutuallyExclusive([[3,.4],[4,0.1],[1,0.01],[2,0.09],[5,0.2],[6,0.1]], 1, 6) );
            //--> null, "Check the total probability, expected null")
console.log(mutuallyExclusive([[1,0.1],[2,0.14],[3,0.16],[4,0.2],[5,0.15],[6,.25]], 1, 4));
	//--> 0.30.toFixed(2), "Check the sum of probabilities for rolling 1 and 4 - expected 0.30")
console.log(mutuallyExclusive([[1,0.6],[2,0.1001],[3,0.0999],[4,0.1],[5,0.05],[6,0.05]], 3, 4));
	//-->0.20.toFixed(2), "Check the sum of probabilities for rolling 3 and 4 - expected 0.20")


//Given a string, return a new string that has transformed based on the input:
//  Change case of every character, ie. lower case to upper case, upper case to lower case.
//  Reverse the order of words from the input.
//	You may assume the input only contain English alphabet and spaces.
//example:
//		stringTransformer('Example Input')should return 'iNPUT eXAMPLE'

function stringTransformer(str) {
  str=str.split(" ").reverse().join(" ").split("");   // this line turns the string into an array to reverse the order, puts it back into a string and then splits it back into an array by each individual element.

  return str.map( function (c,i,a) { (c===c.toUpperCase() ) ? c= c.toLowerCase() : c= c.toUpperCase();   return c;  } ).join("");		// this returns a string joined from a new array that switched the case of each letter.

}

console.log(stringTransformer ("Example Input"));
	//-->'iNPUT eXAMPLE'

//RoboScript #1 - Implement Syntax Highlighting
//Story
//You are a computer scientist and engineer who has recently founded a firm which sells a toy product called MyRobot
//which can move by receiving a set of instructions by reading a file containing a script. Initially you have planned
//the robot to be able to interpret JavaScript files for its movement instructions but you later decided that it would
//make MyRobot too hard to operate for most customers out there who aren't even computer programmers in the first place.
//For this reason, you have decided to invent a new (esoteric) scripting language called RoboScript which has a much simpler
//syntax so non-computer programmers can easily learn how to write scripts in this language which would enable them to
//properly operate MyRobot. However, you are currently at the initial stage of inventing this new Esolang. The first step
//to popularize this (esoteric) scripting language is naturally to invent a new editor for it which provides syntax
//highlighting for this language so your customers feel like they are writing a proper program when they are writing scripts for MyRobot.

//Task
//Your MyRobot-specific (esoteric) scripting language called RoboScript only ever contains the following characters: F, L, R, the digits 0-9 and brackets (( and )).
//Your goal is to write a function highlight which accepts 1 required argument code which is the RoboScript program passed in as a string and returns the script with syntax highlighting.
//The following commands/characters should have the following colors:
/*  F - Wrap this command around <span style="color: pink"> and </span> tags so that it is highlighted pink in our editor
    L - Wrap this command around <span style="color: red"> and </span> tags so that it is highlighted red in our editor
    R - Wrap this command around <span style="color: green"> and </span> tags so that it is highlighted green in our editor
    Digits from 0 through 9 - Wrap these around <span style="color: orange"> and </span> tags so that they are highlighted orange in our editor
    Round Brackets - Do not apply any syntax highlighting to these characters		*/

//And for multiple characters with the same color, simply wrap them with a single <span> tag of the correct color:
//Note that the use of <span> tags must be exactly the same format as demonstrated above. Even if your solution produces the same visual result as the expected answers, if you miss a space betwen "color:" and "green", for example, you will fail the tests.


//For example:
function highlight(code) {
  var hl={ F:"<span style=\"color: pink\">", L:"<span style=\"color: red\">", R:"<span style=\"color: green\">", num:"<span style=\"color: orange\">", end:"</span>" },
  c=code.split(""), arr=[], s="", other=["0","1", "2","3","4","5","6","7","8","9"];

  for (var i=0; i<c.length; i++){
    s= c[i];
    if (c[i]==="(" || c[i]===")"){ arr.push(c[i]); continue;}		// this line checks if the character is a ( or ) in which case it adds it directly to arr and skips the inner loop.

    if (i=== c.length-1){ arr.push(c[i]); continue;};

    for (var d=i; d<c.length; d++){
      if ( other.indexOf(c[d])!=-1 && other.indexOf(c[d+1]) !=-1  )  { s+=c[d+1] }		// this checks if the character is a number and if the next character is a number (by checking if it is anything else) and if they are both then it adds them together in s.

      else if (c[d]=== c[d+1]){ s+= c[d+1];  }// this checks if the character and the one after it are the same.  If they are then i combine them into s.

      else  { arr.push(s); break}	//if the character is not the same as the next, or they are both not numbers, then it adds the current s to the arr array and breaks the inner loop.
    }		// end of inner loop

    i=d;		// this sets i equal to d to skip the characters that d already checked
  }		// end of outter loop
  s="";

  for (var i=0; i<arr.length; i++){
    if ( arr[i][0].match(/[()]/gi) ){ s+= arr[i]; continue}
	if ( (arr[i][0]).match(/[0-9]/gi) ){ s+= hl.num + arr[i] + hl.end}
    else { s+= hl[arr[i][0]] + arr[i] + hl.end};
  }

  return s;
}
console.log(highlight("F3RF5LF7"));
  			// => "<span style=\"color: pink\">F</span><span style=\"color: orange\">3</span><span style=\"color: green\">R</span><span style=\"color: pink\">F</span><span style=\"color: orange\">5</span><span style=\"color: red\">L</span><span style=\"color: pink\">F</span><span style=\"color: orange\">7</span>"

console.log(highlight("FFFR345F2LL"));
// => "<span style=\"color: pink\">FFF</span><span style=\"color: green\">R</span><span style=\"color: orange\">345</span><span style=\"color: pink\">F</span><span style=\"color: orange\">2</span><span style=\"color: red\">LL</span>"


//this is my new answer to the challenge above using reg ex
function highlight(code) {
  var hl={ F:"", L:"", R:"", num:"", end:"</span>" },
  c=code.split("");
  code=code.replace(/(F+)/g, `<span style=\"color: pink\">$1</span>`).
  	replace(/(L+)/g, `<span style=\"color: red\">$1</span>`).
  	replace(/(R+)/g, `<span style=\"color: green\">$1</span>`).
  	replace(/(\d+)/g, `<span style=\"color: orange\">$1</span>`);
  return code;
}


//Write a function that receives two strings and returns n, where n is equal to the number of characters we should shift the first string forward to match the second.
//For instance, take the strings "fatigue" and "tiguefa". In this case, the first string has been rotated 5 characters forward to produce the second string, so 5 would be returned.
//If the second string isn't a valid rotation of the first string, the method returns -1.

function shiftedDiff(s1, s2){
  var t=0, arr=[], temp; s2=s2.split("");

  for (var i=0; i<s2.length; i++){		// this loop is to shift (or rotate) the s2 string until it matches s1 if it can.

    if (s1===s2.join("") ){ return t};		// this is to check if s1 and s2 equal each other, if it does then I return t (total)

    temp=s2[0];
    s2.shift();
    s2.push(temp);
    t+=1;				// these lines are to first make temp equal the first element in the current, shift that first element out of s2, push that element into the back of s2 using temp, and then add 1 to t.

  }		// end of loop

  return -1;		// if the loop does not return t, then s1 and s2 will never match and i return -1.
}

console.log(shiftedDiff("coffee", "eecoff"));// => 2
console.log(shiftedDiff("eecoff", "coffee"));// => 4
console.log(shiftedDiff("moose", "Moose"));// => -1
console.log(shiftedDiff("isn't", "'tisn"));// => 2
console.log(shiftedDiff("Esham", "Esham"));// => 0
console.log(shiftedDiff("dog", "god"));// => -1


//  here is a better answer to the challenge above.
function shiftedDiff(first, second) {
  if (first.length != second.length) return -1
  return (second + second).indexOf(first)
}


//Extend the array object with a function to return all elements of that array, except the ones with the indexes passed in the parameter.
/*For example:
	var array = ['a', 'b', 'c', 'd', 'e'];
	var array2 = array.except([1,3]);
	// array2 should contain ['a', 'c', 'e'];

The function should accept both array as parameter but also a single integer, like this:
	var array = ['a', 'b', 'c', 'd', 'e'];
	var array2 = array.except(1);
	// array2 should contain ['a', 'c', 'd', 'e'];		*/

Array.prototype.except = function(num){
  var arr=this, ar=[];

	if (typeof (num) ==="object" ) {		// this if statement is for the num given that are in an array.  it runs a loop that pushes all of the elements into the ar array except for the ones at the index's in num.

      for (var i=0; i<arr.length; i++) {
           if ( num.indexOf(i)!= -1) { continue;}
      	ar.push(arr[i]);
    }	//end of loop

  	return ar;
	}		//if statement end

   else if ( typeof (num) ==="number" ){		// this if statement is for the num's given that are single numbers.  It does the same of the if statement above, running it through a loop passing all of the elements except the one at index num.

     for (var i=0; i<arr.length; i++){
       if (i===num){ continue; }
       ar.push( arr[i]);
     }		// end of loop

     return ar;
   }  	// end of if statment
}

var array = ['a', 'b', 'c', 'd', 'e'];

console.log(array.except([1,3]) );//, -->['a', 'c', 'e']);
console.log(array.except(1)); //, 	  -->['a', 'c', 'd', 'e']);
console.log(array.except(0) );//,	  -->['b', 'c', 'd', 'e']);


still in progress
//Allergies
//Write a program that, given a person's allergy score, can tell them whether or not they're allergic to a given item, and their full list of allergies.
//An allergy test produces a single numeric score which contains the information about all the allergies the person has (that they were tested for).
//the list of items (and their value) that were tested are:
/*    eggs (1)
    peanuts (2)
    shellfish (4)
    strawberries (8)
    tomatoes (16)
    chocolate (32)
    pollen (64)
    cats (128)		*/

//So if Tom is allergic to peanuts and chocolate, he gets a score of 34.
//Now, given just that score of 34, your program should be able to say:
//    Whether Tom is allergic to any one of those allergens listed above.
//    All the allergens Tom is allergic to., sorted alphabetically

//Example:
//You will be provided with a class Allergies which will have 2 methods
//    (is_allergic_to) 		Checks if Tom is allergic to a particular allergen. Returns True if Tom is allergic, False otherwise
//    (allergies)			Returns a list of what Tom is allergic to. This list must be sorted alphabetically
//Must Dos:
//Ensure that your function throws a TypeError for invalid inputs such as None(Null), floats, strings, or any data type that is not an integer.

Hint: Use Bitwise ANDing


function Allergies(score){
  this.as = {
    "eggs": 1,
    "peanuts": 2,
    "shellfish": 4,
    "strawberries": 8,
    "tomatoes": 16,
    "chocolate": 32,
    "pollen": 64,
    "cats": 128
  }

  this.isAllergicTo=function(allergen){

    for (var i in this.as){
      var x;
      if (this.as[i]> score) {

    }
  }

  this.allergies=function(){
    //your code here
  }

}


var allergies = new Allergies(5);
console.log(allergies.isAllergicTo("eggs"));		//, true);
console.log(allergies.isAllergicTo("shellfish"));	//, true);
console.log(allergies.isAllergicTo("strawberries"));	//, false);
