
//this is similar to another street fighter selection challenge that i have done but this one is harder.  the fighter selection grid will be different each time and there will be less fighters in some of the rows(arrays)
//here is an example:The first character of the first row (Ryu) is not aligned with the first of the second row (Balrog) but with the second (Ken) and the same goes with the other side; therefore we need to introduce something new, like an offset: the Empty Space.
//The empty space, represented as empty string "", will allow us to keep the grid aligned and rectangular, with spaces that won't be selectable. In this case we need 2 empty spaces (3 rows x 6 columns = 18 slots, 18 slots - 16 characters = 2 empty spaces). Like this:
// |        | Ryu    | E.Honda  | Blanka  | Guile   |         |
// | Balrog | Ken    | Chun Li  | Zangief | Dhalsim | Sagat   |
// | Vega   | T.Hawk | Fei Long | Deejay  | Cammy   | M.Bison |
//The moves of the selection cursor are the same as before: rotate horizontally but stop vertically. When you find empty spaces (1 or more) you need to skip them if you approach them horizontally and get to the next selectable slot with the next fighter on the left or right; and if you approach them vertically you need to just stop and stay where you are.
//Example: if you are on Ryu and move left, you must get to Guile; if you are on Balrog and move up, you must stay on Balrog.
//Notice: I might put empty spaces right in the middle and the rectangular grids can be any size, not only 3x6, deal with this too.
//WHAT'S NEW
//So, let's resume what are the new issues in this harder version of the Kata:
//    The initial position might be any non-empty slot in the grid (given as input).
//    The characters grid (also given as input) might have any rectangular layout, not only 3 rows.
//    The grid might contain empty spaces, both on the borders or right in the middle.
function streetFighterSelection(fighters, position, m){
  if (m.length===0){ return [];}
  // first i make these three variables. arr is what i will put in the fighter selected from each m (move).  d is the lenght of the inner arrays in fighters, this is just to make the coding easier so i don't have to type out fighters[x].length-1 each time.
  //x and y will be the position in the fighters array. X will be wich of the two big arrays in fighters (which row of fighters) and Y will be witch fighter in that row ( the element inside that x array)
  var x=position[0],y=position[1],d=fighters[x].length-1, arr=[];
  // i make this for loop to check what move is being made (up, down...) and adjust the x and y variables accordingly
  	for (var i=0; i<m.length; i++){
      // if the move is up or down then i change the x var which will change which of the two arrays is being selected in the fighters array.
      // but as the selecter can't go up past the top row or down past the bottom row if this happense then i leave the x value as it is.  i also make sure that the next fighter choosen isn't a blank space ("").
      //with this harder street fighter challenge i also have to check for white spaces. so moving up or down i treat these white spaces like i can't go any farther in that direct so i leave the x variable as it is.
      if (m[i]==="up" && (x!=0) && (fighters[x-1][y] != "")){ x--};
      if (m[i]=== "down" && (x!=fighters.length-1) && (fighters[x+1][y] != "")) { x++ };
      // if the move is right or left i change the y variable which will change what fighter in that row is being selected.
      // but just like the x variable there is a twist. if the y value is all the way to the right and moves right it goes back to the begining of that row, same with the left it will go to the end of the row.
      //the white spaces make the left and right movemenents much harder than up or down.  if the white space is in the middle of the array then i can just skip two spots in the direction that i am going. but if the white spaces are at the end it is harder.
      //whichever way i am going i have to check for the white spaces, if that space happens to be the end of that row in whichever way then i have to check if the spot i am going to switch to is also a white space.
      //for example if i am going left and the row has 4 spots and i start of in the second (index 1) and there are white spaces at both ends then i have to skip three times to end on index 2.
      if (m[i]=== "right"){
        if (y===d){
            if (fighters[x][0] != ""){ y=0 }
        	else { y=1;}
        }
        //here is where i have to check two spaces in advance for the white spaces and check if i am at the end of the row if i skip that space or if the left most space is a white space.
        else if (fighters[x][y+1] === ""){
          	if (y+1===d){
              if (fighters[x][0] != ""){ y=0 }
              else {y=1}	}
          	else {y+=2}
        }
        else { y++ }; 	}
      if (m[i]==="left"){
        if (y===0){
            if (fighters[x][d] != "" ){ y=d}
          	else { y=d-1}
        }
        //here i am checking two spots to the left like i did with the right movement
        else if (fighters[x][y-1]=== ""){
          if (y-1===0){
            if (fighters[x][d] != "" ){ y=d}
            else { y=d-1;}
          }
          else {y-=2}
        }
        else { y--};	}
      // at the end of each iteration of the loop i push the result of the new position in fighters into the arr array.
      arr.push (fighters[x][y]);
    }
  return arr;
}
var f =[
	[       "",    "Ryu",  "E.Honda",  "Blanka",   "Guile", ""       ],
	[ "Balrog",    "Ken",  "Chun Li", "Zangief", "Dhalsim", "Sagat"  ],
	[   "Vega", "T.Hawk", "Fei Long",  "Deejay",   "Cammy", "M.Bison"]
];
console.log(streetFighterSelection(f, [1,5],["up","up","up","up"]));
//-->['Sagat','Sagat','Sagat','Sagat'];

//You will be given an array of objects representing data about developers who have signed up to attend the next web development meetup that you are organising. Three programming languages will be represented: Python, Ruby and JavaScript.
//return true if the number of meetup participants representing any of the three programming languages is at MOST 2 times higher than the number of developers representing any of the remaining programming languages; or
//return false otherwise.

function isLanguageDiverse(list) {
  // first i make an obj with the three languages with all of their values at 0.
  var obj= { "JavaScript":0, "Ruby":0, "Python":0 };
  // i use the map() method to run throught he list and every time it goes through someone's dat it increase that lanugaes value in the obj object.
  list.map( function (c,i,a) { return obj[c.language] ++});
  // now i make two for loops to run through obj.
  for (var i in obj){
    // this inner loop allows the outer loop to check all of the other values in obj making sure that the outer loops value isn't more than two times bigger an any other lanugae.  if it is it returns false.
    // i used a second inside for loop so i could check every value agains all other values not just the ones after it which is what i thought would happen if used just one loop.
    for (var d in obj){
    	if (obj[i]> (obj[d]*2) ) { return false;}
    }
  }
  // now i return true, which the function should only get this far if it meets the challenges requirements
  return true;
}
var l1 = [
  { firstName: 'Daniel', lastName: 'J.', country: 'Aruba', continent: 'Americas', age: 42, language: 'Python' },
  { firstName: 'Kseniya', lastName: 'T.', country: 'Belarus', continent: 'Europe', age: 22, language: 'Ruby' },
  { firstName: 'Sou', lastName: 'B.', country: 'Japan', continent: 'Asia', age: 43, language: 'Ruby' },
  { firstName: 'Hanna', lastName: 'L.', country: 'Hungary', continent: 'Europe', age: 95, language: 'JavaScript' },
  { firstName: 'Jayden', lastName: 'P.', country: 'Jamaica', continent: 'Americas', age: 18, language: 'JavaScript' },
  { firstName: 'Joao', lastName: 'D.', country: 'Portugal', continent: 'Europe', age: 25, language: 'JavaScript' }
];
console.log( isLanguageDiverse(l1));
//-->false  as the number of JavaScript developers (3) is 3 times higher than the number of Python developers (1). It can't be more than 2 times higher to be regarded as language-diverse.

//In this kata, your goal is to write a function which will reverse the vowels in a string. Any characters which are not vowels should remain in their original position. Here are some examples:
function reverseVowels(str) {
  //I make several variables for this challenge. vow is an array of all the vowels both upper and lower case, this is to compare the letter in the given string.  count will be used to find the vowel indexes in srting.
  //arr is a copy of str.split that will be left along and used for switching vowels in str.  str i change into an array with all of the letters and elements split apart.
  var vow=["a","e","i","o","u","A","E","I","O","U"], count= new Object(), arr=str.split(""),str=str.split("");
  // here i use the map method to run through the str array and every time i find a vowel(using the vow array to check) i put that index number into the count object.
  str.map( function (c,i,a) { if (vow.indexOf(c)!=-1){return count[i]=i;} });
  // now i make two more variables.  x which is the count obj in array form, and y which is the same thing but reversed.  i will use these in the loop below
  var x=Object.keys(count), y=Object.keys(count).reverse();
  //here i make a for loop to switch the vowels.  i made the loop go half the length of x which is how many vowels there are in str. i  did this because i will be using y (wich is x reversed) and x together to switch the vowels so i only need to go half the lenght of each
  for (var i=0; i<x.length/2; i++){
    // each iteration of the loop i make use x and y as index's in the str array
    // in the first iteratoin i make the first vowel in str (which would be the first number in x) equal the last vowel (which is the last number in y as it is the revers of x). And vice versa using the arr array which is not changed at all so it equals the original str array.
    str[x[i]]=str[y[i]];
    str[y[i]]=arr[x[i]];
  }
  return	str.join("");
}
console.log(reverseVowels("Hello!")); // "Holle!"
console.log(reverseVowels("Tomatoes")); // "Temotaos"
console.log(reverseVowels("Reverse Vowels In A String")); // "RivArsI Vewols en e Streng"
